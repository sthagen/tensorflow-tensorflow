diff --git a/shardy/dialect/mpmd/ir/utils.cc b/shardy/dialect/mpmd/ir/utils.cc
index a58f533..0176fbf 100644
--- a/shardy/dialect/mpmd/ir/utils.cc
+++ b/shardy/dialect/mpmd/ir/utils.cc
@@ -16,6 +16,7 @@ limitations under the License.
 #include "shardy/dialect/mpmd/ir/utils.h"
 
 #include <algorithm>
+#include <cstddef>
 #include <cstdint>
 #include <functional>
 #include <optional>
@@ -27,7 +28,9 @@ limitations under the License.
 #include "llvm/ADT/STLExtras.h"
 #include "llvm/ADT/SmallVector.h"
 #include "llvm/ADT/StringRef.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/ErrorHandling.h"
+#include "llvm/Support/raw_ostream.h"
 #include "mlir/Bytecode/BytecodeWriter.h"
 #include "mlir/Dialect/Func/IR/FuncOps.h"
 #include "mlir/IR/Attributes.h"
@@ -139,8 +142,6 @@ FuncOp GetMainFunction(ModuleOp module) {
 
 bool IsMpmdModule(ModuleOp module) { return !GetMpmdFunctions(module).empty(); }
 
-bool IsMainFunction(FuncOp func_op) { return func_op.getSymName() == "main"; }
-
 bool IsMpmdFunction(FuncOp func_op) { return func_op->hasAttr(kTopologyAttr); }
 
 bool IsSpmdFunction(FuncOp func_op) { return func_op->hasAttr(kMeshShapeAttr); }
@@ -164,8 +165,6 @@ TopologyAttr GetTopology(ModuleOp module_op) {
   return GetTopology(mpmd_funcs.front());
 }
 
-void RemoveMesh(FuncOp func_op) { func_op->removeAttr(kMeshShapeAttr); }
-
 namespace {
 
 void SetTopologyImpl(ArrayRef<NamedMeshAttr> meshes, FuncOp func) {
@@ -490,9 +489,9 @@ bool IsLoweredWithSdy(ModuleOp module) {
   return module->hasAttr(kIsSdyLowered);
 }
 
-bool IsRemat(Operation* op) { return op->hasAttr(kRematAttributeName); }
+bool IsRemat(mlir::Operation* op) { return op->hasAttr(kRematAttributeName); }
 
-void MarkAsRemat(Operation* op, RewriterBase& rewriter) {
+void MarkAsRemat(mlir::Operation* op, RewriterBase& rewriter) {
   op->setAttr(kRematAttributeName, rewriter.getUnitAttr());
 }
 
diff --git a/shardy/dialect/mpmd/ir/utils.h b/shardy/dialect/mpmd/ir/utils.h
index 208b663..81ee83d 100644
--- a/shardy/dialect/mpmd/ir/utils.h
+++ b/shardy/dialect/mpmd/ir/utils.h
@@ -16,13 +16,19 @@ limitations under the License.
 #ifndef SHARDY_DIALECT_MPMD_IR_UTILS_H_
 #define SHARDY_DIALECT_MPMD_IR_UTILS_H_
 
+#include <cstddef>
 #include <cstdint>
 #include <functional>
 #include <optional>
 #include <string>
+#include <tuple>
 #include <utility>
 #include <vector>
 
+#include "llvm/ADT/DenseMapInfo.h"
+#include "llvm/ADT/Hashing.h"
+#include "llvm/ADT/STLExtras.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/raw_ostream.h"
 #include "mlir/Dialect/Func/IR/FuncOps.h"
 #include "mlir/IR/Builders.h"
@@ -147,9 +153,6 @@ func::FuncOp GetMainFunction(ModuleOp module);
 // topology.
 bool IsMpmdModule(ModuleOp module);
 
-// Returns true iff the function is named "main".
-bool IsMainFunction(func::FuncOp func_op);
-
 // Returns true if the function is annotated with a topology.
 bool IsMpmdFunction(func::FuncOp func_op);
 
@@ -174,9 +177,6 @@ TopologyAttr GetTopology(func::FuncOp func_op);
 // Precondition: `IsMpmdModule(module_op)` must be true.
 TopologyAttr GetTopology(ModuleOp module_op);
 
-// Removes the mesh attribute from the function.
-void RemoveMesh(func::FuncOp func_op);
-
 // A flat mesh is a vector of (axis_name, axis_size) pairs.
 using FlatMesh = std::vector<std::pair<std::string, int>>;
 
diff --git a/shardy/dialect/sdy/transforms/export/BUILD b/shardy/dialect/sdy/transforms/export/BUILD
index 0c5aa15..eaaba0c 100644
--- a/shardy/dialect/sdy/transforms/export/BUILD
+++ b/shardy/dialect/sdy/transforms/export/BUILD
@@ -76,7 +76,6 @@ cc_library(
     hdrs = ["explicit_reshards_util.h"],
     deps = [
         "//shardy/common:file_utils",
-        "//shardy/common:logging",
         "//shardy/dialect/sdy/ir:axis_list_ref",
         "//shardy/dialect/sdy/ir:dialect",
         "//shardy/dialect/sdy/transforms/common:op_properties",
diff --git a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
index 3679a03..8df82f8 100644
--- a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
+++ b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.cc
@@ -34,7 +34,6 @@ limitations under the License.
 #include "mlir/IR/Types.h"
 #include "mlir/IR/Value.h"
 #include "mlir/Support/LLVM.h"
-#include "shardy/common/logging.h"
 #include "shardy/dialect/sdy/ir/axis_list_ref.h"
 #include "shardy/dialect/sdy/ir/dialect.h"
 #include "shardy/dialect/sdy/ir/enums.h"
@@ -227,24 +226,25 @@ void insertExplicitReshards(Operation* op,
 
 // Inserts an `sdy.all-reduce` for each result of `op` if any of its reduction
 // factors is sharded in `commonAxesPerFactor`.
-void insertAllReduces(Operation* op, const AxesPerFactor& commonAxesPerFactor,
-                      const Mesh& mesh, OpShardingRuleAttr shardingRule,
-                      IRRewriter& rewriter) {
+void insertAllReduces(Operation* op,
+                      const AxesPerFactorWithMesh& commonAxesPerFactorWithMesh,
+                      OpShardingRuleAttr shardingRule, IRRewriter& rewriter) {
   rewriter.setInsertionPointAfter(op);
   SmallVector<AxisRefAttr> reductionAxes;
   for (int64_t reductionFactor : shardingRule.getReductionFactors()) {
-    reductionAxes.append(commonAxesPerFactor[reductionFactor]);
+    reductionAxes.append(commonAxesPerFactorWithMesh.axes[reductionFactor]);
   }
   if (reductionAxes.empty()) {
     return;
   }
+  MeshAttr mesh = commonAxesPerFactorWithMesh.mesh.attr();
   // TODO(tomnatan): consider supporting multi-input all-reduce op.
   for (Value result : op->getResults()) {
     TensorShardingAttr resultSharding =
-        getOrCreateSharding(result, mesh.name(),
+        getOrCreateSharding(result, commonAxesPerFactorWithMesh.mesh.name(),
                             /*closedIfMissing=*/true);
-    SmallVector<AxisRefAttr> allReduceAxes = getAxisSetDiff(
-        reductionAxes, resultSharding.getUnreducedAxes(), mesh.attr());
+    SmallVector<AxisRefAttr> allReduceAxes =
+        getAxisSetDiff(reductionAxes, resultSharding.getUnreducedAxes(), mesh);
     if (allReduceAxes.empty()) {
       continue;
     }
@@ -745,11 +745,22 @@ TensorShardingAttr getShardingOfTensorIndex(
                                    : outShardings[tensorIndex - numOperands];
 }
 
+Mesh getMeshOrDefault(TensorShardingAttr sharding,
+                      const SymbolTable& symbolTable, const Mesh& defaultMesh) {
+  if (!sharding) {
+    return defaultMesh;
+  }
+  StringRef meshName =
+      getCommonMeshName({sharding}, {}, symbolTable, /*ignoreDeviceIds=*/false)
+          .value();
+  return Mesh(getMeshAttr(symbolTable, meshName), meshName);
+}
+
 // Assumes that:
 // 1. Either tensor does not have factors that need replication.
 // 2. Both tensors have the same mesh but may have different device orders.
 // 3. The factor shardings are not compatible.
-AxesPerFactor findCommonAxesOnUnaryOperation(
+AxesPerFactorWithMesh findCommonAxesOnUnaryOperation(
     ArrayRef<TensorShardingAttr> inShardings,
     ArrayRef<TensorShardingAttr> outShardings,
     const ShardingProjection& shardingProjection,
@@ -762,7 +773,7 @@ AxesPerFactor findCommonAxesOnUnaryOperation(
   // If one tensor can not be chosen to be common axes, return empty so it skips
   // inserting explicit reshards for the operation.
   if (tensorIndexToPrefer == std::nullopt) {
-    return AxesPerFactor();
+    return AxesPerFactorWithMesh();
   }
 
   // Set factor shardings to make sure factors that do not appear in the
@@ -788,7 +799,14 @@ AxesPerFactor findCommonAxesOnUnaryOperation(
            .factorIndexToSharding) {
     factorAxisRefs[factorIndex] = factorSharding.axisRefs;
   }
-  return factorAxisRefs;
+
+  // TODO(enver): Instead use a call back.
+  TensorShardingAttr shardingToPrefer =
+      getShardingOfTensorIndex(*tensorIndexToPrefer, inShardings, outShardings,
+                               shardingRule.getNumOperands());
+  return AxesPerFactorWithMesh(
+      std::move(factorAxisRefs),
+      getMeshOrDefault(shardingToPrefer, symbolTable, /*defaultMesh=*/mesh));
 }
 
 void distributeAxisRefsToBatchingFactors(
@@ -838,23 +856,48 @@ void distributeAxisRefsToBatchingFactors(
   }
 }
 
-AxesPerFactor findCommonAxes(ArrayRef<TensorShardingAttr> inShardings,
-                             ArrayRef<TensorShardingAttr> outShardings,
-                             const ShardingProjection& shardingProjection,
-                             OpShardingRuleAttr shardingRule,
-                             ArrayRef<int64_t> tensorSizes,
-                             const SymbolTable& symbolTable, const Mesh& mesh) {
+Mesh getMostCommonMesh(ArrayRef<TensorShardingAttr> inShardings,
+                       ArrayRef<TensorShardingAttr> outShardings,
+                       const SymbolTable& symbolTable,
+                       const Mesh& defaultMesh) {
+  int64_t maxMeshCount = 0;
+  llvm::SmallDenseMap<StringRef, int64_t> meshCounts;
+  Mesh mostCommonMesh = defaultMesh;
+  for (const TensorShardingAttr sharding :
+       llvm::concat<const TensorShardingAttr>(inShardings, outShardings)) {
+    if (!isFullyReplicated(sharding)) {
+      const Mesh meshOfSharding =
+          getMeshOrDefault(sharding, symbolTable, defaultMesh);
+      const int64_t meshCount = ++meshCounts[meshOfSharding.name()];
+      if (meshCount > maxMeshCount) {
+        maxMeshCount = meshCount;
+        mostCommonMesh = meshOfSharding;
+      }
+    }
+  }
+  return mostCommonMesh;
+}
+
+AxesPerFactorWithMesh findCommonAxes(
+    ArrayRef<TensorShardingAttr> inShardings,
+    ArrayRef<TensorShardingAttr> outShardings,
+    const ShardingProjection& shardingProjection,
+    OpShardingRuleAttr shardingRule, ArrayRef<int64_t> tensorSizes,
+    const SymbolTable& symbolTable, const Mesh& defaultMesh) {
   // Return without inserting reshards if any factor sharding has overflow
   // axes. This case is not handled yet.
   // TODO(enver): Handle the case when factor shardings have overflow axes.
   if (hasOverflowAxes(shardingProjection)) {
-    return AxesPerFactor();
+    return AxesPerFactorWithMesh();
   }
 
+  const Mesh mesh =
+      getMostCommonMesh(inShardings, outShardings, symbolTable, defaultMesh);
+
   // Checks if factors are sharded the same way across operands and results.
   if (std::optional<AxesPerFactor> commonAxesPerFactor =
           getCompatibleFactorShardings(shardingProjection, shardingRule)) {
-    return std::move(commonAxesPerFactor.value());
+    return AxesPerFactorWithMesh(std::move(commonAxesPerFactor.value()), mesh);
   }
 
   // Handle the special case of unary operations without factors that need
@@ -887,7 +930,7 @@ AxesPerFactor findCommonAxes(ArrayRef<TensorShardingAttr> inShardings,
     }
   }
 
-  return factorCommonAxes;
+  return AxesPerFactorWithMesh(std::move(factorCommonAxes), mesh);
 }
 
 SmallVector<int64_t> getTensorSizes(Operation* op) {
@@ -915,24 +958,20 @@ bool shouldReshard(TensorShardingAttr sourceSharding,
 
 TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
     OpOperand& use, TensorShardingAttr sourceSharding,
-    TensorShardingAttr userSharding, const SymbolTable& symbolTable,
-    IRRewriter& rewriter) {
-  if (!sourceSharding || sourceSharding.getUnreducedAxes().empty()) {
+    TensorShardingAttr userSharding, MeshAttr mesh, IRRewriter& rewriter) {
+  ArrayRef<AxisRefAttr> targetUnreducedAxes =
+      userSharding ? userSharding.getUnreducedAxes() : ArrayRef<AxisRefAttr>();
+
+  if (!sourceSharding) {
+    return nullptr;
+  }
+  if (sourceSharding.getUnreducedAxes().empty() ||
+      targetUnreducedAxes == sourceSharding.getUnreducedAxes()) {
     return sourceSharding;
   }
-  MeshAttr mesh = sourceSharding.getMesh(symbolTable);
-  ArrayRef<AxisRefAttr> sourceUnreducedAxes = sourceSharding.getUnreducedAxes();
-  ArrayRef<AxisRefAttr> targetUnreducedAxes;
-  if (userSharding) {
-    targetUnreducedAxes = userSharding.getUnreducedAxes();
-    // TODO(enver): Support the case the meshes differ only on device orders.
-    SDY_CHECK(targetUnreducedAxes.empty() ||
-              mesh.equals(userSharding.getMesh(symbolTable)))
-        << "source and user shardings have different meshes for unreduced "
-           "axes.";
-  }
-  SmallVector<AxisRefAttr> allReduceAxes =
-      getAxisSetDiff(sourceUnreducedAxes, targetUnreducedAxes, mesh);
+
+  SmallVector<AxisRefAttr> allReduceAxes = getAxisSetDiff(
+      sourceSharding.getUnreducedAxes(), targetUnreducedAxes, mesh);
   if (allReduceAxes.empty()) {
     return sourceSharding;
   }
@@ -967,30 +1006,29 @@ bool differentOperandShardingFromFirstResult(Operation* op) {
   });
 }
 
-void insertExplicitReshardsOnOp(Operation* op,
-                                ArrayRef<TensorShardingAttr> inShardings,
-                                ArrayRef<TensorShardingAttr> outShardings,
-                                IRRewriter& rewriter,
-                                const SymbolTable& symbolTable,
-                                OpShardingRuleAttr shardingRule,
-                                const bool onFullVersion, const Mesh& mesh) {
+void insertExplicitReshardsOnOp(
+    Operation* op, ArrayRef<TensorShardingAttr> inShardings,
+    ArrayRef<TensorShardingAttr> outShardings, IRRewriter& rewriter,
+    const SymbolTable& symbolTable, OpShardingRuleAttr shardingRule,
+    const bool onFullVersion, const Mesh& defaultMesh) {
   if (!onFullVersion) {
     return;
   }
 
   ShardingProjection shardingProjection = ShardingProjection::build(
-      inShardings, outShardings, shardingRule, mesh.attr(),
+      inShardings, outShardings, shardingRule, defaultMesh.attr(),
       /*closedIfMissing=*/true);
 
   UpdateTensorShardings updateTensorShardings(shardingRule.getNumOperands(),
                                               shardingRule.getNumResults());
-  AxesPerFactor commonAxesPerFactor =
-      findCommonAxes(inShardings, outShardings, shardingProjection,
-                     shardingRule, getTensorSizes(op), symbolTable, mesh);
-  if (commonAxesPerFactor.empty()) {
+  AxesPerFactorWithMesh commonAxesPerFactorWithMesh = findCommonAxes(
+      inShardings, outShardings, shardingProjection, shardingRule,
+      getTensorSizes(op), symbolTable, defaultMesh);
+  if (commonAxesPerFactorWithMesh.empty()) {
     return;
   }
-  for (const auto& [index, axes] : llvm::enumerate(commonAxesPerFactor)) {
+  for (const auto& [index, axes] :
+       llvm::enumerate(commonAxesPerFactorWithMesh.axes)) {
     // TODO(enver): Add unit tests to test overflow axes are cleared after
     // handling the case that some factors have overflow axes.
     updateTensorShardings |=
@@ -998,10 +1036,10 @@ void insertExplicitReshardsOnOp(Operation* op,
   }
   insertExplicitReshards(op, inShardings, outShardings, shardingProjection,
                          updateTensorShardings, rewriter, shardingRule,
-                         symbolTable, mesh);
+                         symbolTable, commonAxesPerFactorWithMesh.mesh);
 
   // TODO(b/440055868): Insert a reshard from unreduced to replicated axes.
-  insertAllReduces(op, commonAxesPerFactor, mesh, shardingRule, rewriter);
+  insertAllReduces(op, commonAxesPerFactorWithMesh, shardingRule, rewriter);
 }
 
 }  // namespace sdy
diff --git a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
index 961eb61..d114571 100644
--- a/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
+++ b/shardy/dialect/sdy/transforms/export/explicit_reshards_util.h
@@ -43,6 +43,16 @@ struct Mesh {
   StringRef name() const { return meshName; }
 };
 
+// The struct contains an array of axes list, and a mesh.
+struct AxesPerFactorWithMesh {
+  AxesPerFactor axes;
+  Mesh mesh;
+  AxesPerFactorWithMesh() = default;
+  AxesPerFactorWithMesh(AxesPerFactor axes, Mesh mesh)
+      : axes(std::move(axes)), mesh(mesh) {};
+  bool empty() const { return axes.empty(); }
+};
+
 // Returns true if a reshard is needed to go from source sharding to target
 // sharding.
 bool shouldReshard(TensorShardingAttr sourceSharding,
@@ -59,15 +69,11 @@ bool shouldReshard(TensorShardingAttr sourceSharding,
 // input and produces an unreduced output, we simply respect the existing
 // shardings and match cases where an unreduced axis becomes sharded/replicated.
 //
-// Hard fails if sourceSharding and userSharding have different meshes.
-// TODO(b/442783457): Support when the meshes differ only on device order.
-//
 // Returns the sharding of the inserted all-reduce, or `sourceSharding` if none
 // was inserted.
 TensorShardingAttr insertAllReduceIfUnreducedToReplicated(
     OpOperand& use, TensorShardingAttr sourceSharding,
-    TensorShardingAttr userSharding, const SymbolTable& symbolTable,
-    IRRewriter& rewriter);
+    TensorShardingAttr userSharding, MeshAttr mesh, IRRewriter& rewriter);
 
 // Returns true if any of `axes` overlaps with `axis`.
 bool hasOverlappingAxis(ArrayRef<AxisRefAttr> axes, AxisRefAttr axis);
@@ -91,7 +97,7 @@ void insertExplicitReshardsOnOp(Operation* op,
                                 IRRewriter& rewriter,
                                 const SymbolTable& symbolTable,
                                 OpShardingRuleAttr shardingRule,
-                                bool onFullVersion, const Mesh& mesh);
+                                bool onFullVersion, const Mesh& defaultMesh);
 
 }  // namespace sdy
 }  // namespace mlir
diff --git a/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc b/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
index 04f39d4..16547c7 100644
--- a/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
+++ b/shardy/dialect/sdy/transforms/export/insert_explicit_reshards.cc
@@ -19,7 +19,6 @@ limitations under the License.
 #include <memory>  // IWYU pragma: keep
 #include <optional>
 
-#include "llvm/ADT/DenseMap.h"
 #include "llvm/ADT/STLExtras.h"
 #include "mlir/Dialect/Func/IR/FuncOps.h"  // IWYU pragma: keep
 #include "mlir/Dialect/Func/IR/FuncOps.h"
@@ -37,7 +36,6 @@ limitations under the License.
 #include "shardy/dialect/sdy/transforms/export/passes.h"  // IWYU pragma: keep
 #include "shardy/dialect/sdy/transforms/propagation/op_sharding_rule_registry.h"
 #include "shardy/dialect/sdy/transforms/propagation/sharding_projection.h"
-#include "shardy/dialect/sdy/transforms/propagation/utils.h"
 #include "stablehlo/dialect/StablehloOps.h"
 
 namespace mlir {
@@ -65,7 +63,8 @@ void insertExplicitReshardsToTargetSharding(OpOperand& opOperand,
     // If `operandSharding` has unreduced axes, insert an all-reduce if any of
     // the axes isn't unreduced in the target sharding.
     operandSharding = insertAllReduceIfUnreducedToReplicated(
-        opOperand, operandSharding, targetSharding, symbolTable, rewriter);
+        opOperand, operandSharding, targetSharding,
+        operandSharding.getMesh(symbolTable), rewriter);
   }
 
   if (onFullVersion && shouldReshard(operandSharding, targetSharding)) {
@@ -259,42 +258,6 @@ void processDot(OpTy op, ArrayRef<TensorShardingAttr> inShardings,
   rewriter.replaceAllUsesExcept(op.getResult(), reshardOp, reshardOp);
 }
 
-Mesh getMeshOrDefault(TensorShardingAttr sharding,
-                      const SymbolTable& symbolTable, const Mesh& defaultMesh) {
-  if (!sharding) {
-    return defaultMesh;
-  }
-  // NOTE: sharding always has a meshOrRef because it is a required parameter.
-  return Mesh(sharding.getMesh(symbolTable),
-              cast<FlatSymbolRefAttr>(sharding.getMeshOrRef()).getValue());
-}
-
-Mesh getMostCommonMesh(ArrayRef<TensorShardingAttr> inShardings,
-                       ArrayRef<TensorShardingAttr> outShardings,
-                       const SymbolTable& symbolTable,
-                       const Mesh& defaultMesh) {
-  int64_t maxMeshCount = 0;
-  llvm::SmallDenseMap<StringRef, int64_t> meshCounts;
-  Mesh mostCommonMesh = defaultMesh;
-  for (const TensorShardingAttr sharding :
-       llvm::concat<const TensorShardingAttr>(inShardings, outShardings)) {
-    if (!isFullyReplicated(sharding)) {
-      const Mesh meshOfSharding =
-          getMeshOrDefault(sharding, symbolTable, defaultMesh);
-      const int64_t meshCount = ++meshCounts[meshOfSharding.name()];
-      if (meshCount > maxMeshCount) {
-        maxMeshCount = meshCount;
-        mostCommonMesh = meshOfSharding;
-      }
-    }
-  }
-  return mostCommonMesh;
-}
-
-// Returns the most common mesh. Returns nullopt if any of the following holds:
-//  1. There is no tensor with a sharding attribute.
-//  2. Tensors have different meshes (ignoring device ids)
-//  3. Some tensors have maximal meshes.
 std::optional<Mesh> getMesh(ArrayRef<TensorShardingAttr> inShardings,
                             ArrayRef<TensorShardingAttr> outShardings,
                             const SymbolTable& symbolTable) {
@@ -313,9 +276,7 @@ std::optional<Mesh> getMesh(ArrayRef<TensorShardingAttr> inShardings,
   if (meshAttr.isMaximal()) {
     return std::nullopt;
   }
-  // Return the mesh with the most common device id.
-  return getMostCommonMesh(inShardings, outShardings, symbolTable,
-                           /*defaultMesh=*/Mesh(meshAttr, *meshName));
+  return Mesh(meshAttr, *meshName);
 }
 
 struct InsertExplicitReshardsPass
@@ -369,7 +330,8 @@ struct InsertExplicitReshardsPass
       for (OpOperand& operand : op->getOpOperands()) {
         if (TensorShardingAttr inSharding = getSharding(operand.get())) {
           insertAllReduceIfUnreducedToReplicated(
-              operand, inSharding, outSharding, symbolTable, rewriter);
+              operand, inSharding, outSharding, inSharding.getMesh(symbolTable),
+              rewriter);
         }
       }
 
diff --git a/shardy/dialect/sdy/transforms/export/test/insert_explicit_reshards/meshes.mlir b/shardy/dialect/sdy/transforms/export/test/insert_explicit_reshards/meshes.mlir
index 961cdb6..55efca7 100644
--- a/shardy/dialect/sdy/transforms/export/test/insert_explicit_reshards/meshes.mlir
+++ b/shardy/dialect/sdy/transforms/export/test/insert_explicit_reshards/meshes.mlir
@@ -101,11 +101,9 @@ func.func @negate_axes_incompatible_different_device_orders(%arg0: tensor<210xf3
 
 // CHECK-LABEL: func @negate_axes_incompatible_different_device_orders_output_sharding_is_larger
 func.func @negate_axes_incompatible_different_device_orders_output_sharding_is_larger(%arg0: tensor<210xf32> {sdy.sharding = #sdy.sharding<@mesh_iota, [{"y"}]>}) -> (tensor<210xf32> {sdy.sharding = #sdy.sharding<@mesh_non_iota, [{"x"}]>}) {
-  // TODO(enver): In fact, this can go from <@mesh_non_iota, [{"x"}]> to <@mesh_iota, [{"y"}]> in one reshard, and consequently, in one collective permute.
-  // CHECK: %[[RESHARD_1:.*]] = sdy.reshard %arg0 <@mesh_iota, [{"x"}]> : tensor<210xf32>
-  // CHECK-NEXT: %[[NEGATE:.*]] = stablehlo.negate %[[RESHARD_1]] {sdy.sharding = #sdy.sharding_per_value<[<@mesh_iota, [{"x"}]>]>} : tensor<210xf32>
-  // CHECK-NEXT: %[[RESHARD_2:.*]] = sdy.reshard %[[NEGATE]] <@mesh_non_iota, [{"x"}]> : tensor<210xf32>
-  // CHECK-NEXT: return %[[RESHARD_2]]
+  // CHECK: %[[RESHARD:.*]] = sdy.reshard %arg0 <@mesh_non_iota, [{"x"}]> : tensor<210xf32>
+  // CHECK-NEXT: %[[NEGATE:.*]] = stablehlo.negate %[[RESHARD]]
+  // CHECK-NEXT: return %[[NEGATE]]
   %0 = stablehlo.negate %arg0 {sdy.sharding = #sdy.sharding_per_value<[<@mesh_non_iota, [{"x"}]>]>} : tensor<210xf32>
   return %0 : tensor<210xf32>
 }
diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index b480cc7..217385d 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -72,24 +72,6 @@ diff -ruN --strip-trailing-cr a/clang/include/clang/AST/TypeLoc.h b/clang/includ
             "Inconsistent nested-name-specifier pointer");
      getLocalData()->QualifierData = QualifierLoc.getOpaqueData();
    }
-diff -ruN --strip-trailing-cr a/clang/include/clang/ASTMatchers/ASTMatchers.h b/clang/include/clang/ASTMatchers/ASTMatchers.h
---- a/clang/include/clang/ASTMatchers/ASTMatchers.h
-+++ b/clang/include/clang/ASTMatchers/ASTMatchers.h
-@@ -5739,6 +5739,14 @@
-   return Builder->removeBindings(Predicate);
- }
- 
-+/// Matches a declaration if it declares the same entity as the node previously
-+/// bound to \p ID.
-+AST_MATCHER_P(Decl, declaresSameEntityAsBoundNode, std::string, ID) {
-+  return Builder->removeBindings([&](const internal::BoundNodesMap &Nodes) {
-+    return !clang::declaresSameEntity(&Node, Nodes.getNodeAs<Decl>(ID));
-+  });
-+}
-+
- /// Matches the condition variable statement in an if statement.
- ///
- /// Given
 diff -ruN --strip-trailing-cr a/clang/include/clang/Serialization/ASTReader.h b/clang/include/clang/Serialization/ASTReader.h
 --- a/clang/include/clang/Serialization/ASTReader.h
 +++ b/clang/include/clang/Serialization/ASTReader.h
@@ -225,6 +207,34 @@ diff -ruN --strip-trailing-cr a/clang/lib/AST/ASTImporter.cpp b/clang/lib/AST/AS
    if (T->isCanonicalUnqualified())
      return Importer.getToContext().getCanonicalTagType(*ToDeclOrErr);
  
+diff -ruN --strip-trailing-cr a/clang/lib/AST/ByteCode/InterpBuiltin.cpp b/clang/lib/AST/ByteCode/InterpBuiltin.cpp
+--- a/clang/lib/AST/ByteCode/InterpBuiltin.cpp
++++ b/clang/lib/AST/ByteCode/InterpBuiltin.cpp
+@@ -1830,6 +1830,7 @@
+     assert(Call->getArg(1)->getType()->isVectorType() &&
+            ASTCtx.hasSameUnqualifiedType(Call->getArg(0)->getType(),
+                                          Call->getArg(1)->getType()));
++    (void)ASTCtx;
+     ZeroArg = S.Stk.pop<Pointer>();
+     assert(ZeroArg.getFieldDesc()->isPrimitiveArray());
+   }
+@@ -2728,6 +2729,8 @@
+   if (!Arg1Type->isVectorType()) {
+     assert(!Arg2Type->isVectorType());
+     assert(!Arg3Type->isVectorType());
++    (void)Arg2Type;
++    (void)Arg3Type;
+ 
+     const Floating &Z = S.Stk.pop<Floating>();
+     const Floating &Y = S.Stk.pop<Floating>();
+@@ -2753,6 +2756,7 @@
+   assert(NumElems == Arg2Type->castAs<VectorType>()->getNumElements() &&
+          NumElems == Arg3Type->castAs<VectorType>()->getNumElements());
+   assert(ElemT->isRealFloatingType());
++  (void)ElemT;
+ 
+   const Pointer &VZ = S.Stk.pop<Pointer>();
+   const Pointer &VY = S.Stk.pop<Pointer>();
 diff -ruN --strip-trailing-cr a/clang/lib/AST/DeclarationName.cpp b/clang/lib/AST/DeclarationName.cpp
 --- a/clang/lib/AST/DeclarationName.cpp
 +++ b/clang/lib/AST/DeclarationName.cpp
@@ -236,37 +246,6 @@ diff -ruN --strip-trailing-cr a/clang/lib/AST/DeclarationName.cpp b/clang/lib/AS
  
    if (const RecordType *ClassRec = ClassType->getAs<RecordType>()) {
      ClassRec->getOriginalDecl()->printName(OS, Policy);
-diff -ruN --strip-trailing-cr a/clang/lib/AST/Decl.cpp b/clang/lib/AST/Decl.cpp
---- a/clang/lib/AST/Decl.cpp
-+++ b/clang/lib/AST/Decl.cpp
-@@ -1604,17 +1604,20 @@
-   // We have just computed the linkage for this decl. By induction we know
-   // that all other computed linkages match, check that the one we just
-   // computed also does.
--  NamedDecl *Old = nullptr;
--  for (auto *I : D->redecls()) {
--    auto *T = cast<NamedDecl>(I);
--    if (T == D)
-+  // We can't assume the redecl chain is well formed at this point,
-+  // so keep track of already visited declarations.
-+  for (llvm::SmallPtrSet<const Decl *, 4> AlreadyVisited{D}; /**/; /**/) {
-+    D = cast<NamedDecl>(const_cast<NamedDecl *>(D)->getNextRedeclarationImpl());
-+    if (!AlreadyVisited.insert(D).second)
-+      break;
-+    if (D->isInvalidDecl())
-       continue;
--    if (!T->isInvalidDecl() && T->hasCachedLinkage()) {
--      Old = T;
-+    if (auto OldLinkage = D->getCachedLinkage();
-+        OldLinkage != Linkage::Invalid) {
-+      assert(LV.getLinkage() == OldLinkage);
-       break;
-     }
-   }
--  assert(!Old || Old->getCachedLinkage() == D->getCachedLinkage());
- #endif
- 
-   return LV;
 diff -ruN --strip-trailing-cr a/clang/lib/AST/MicrosoftMangle.cpp b/clang/lib/AST/MicrosoftMangle.cpp
 --- a/clang/lib/AST/MicrosoftMangle.cpp
 +++ b/clang/lib/AST/MicrosoftMangle.cpp
@@ -417,21 +396,10 @@ diff -ruN --strip-trailing-cr a/clang/lib/AST/TypeLoc.cpp b/clang/lib/AST/TypeLo
        /*NameLoc=*/Loc, /*LAngleLoc=*/Loc, /*RAngleLoc=*/Loc);
    initializeArgLocs(Context, getTypePtr()->template_arguments(), getArgInfos(),
                      Loc);
-diff -ruN --strip-trailing-cr a/clang/lib/ASTMatchers/Dynamic/Registry.cpp b/clang/lib/ASTMatchers/Dynamic/Registry.cpp
---- a/clang/lib/ASTMatchers/Dynamic/Registry.cpp
-+++ b/clang/lib/ASTMatchers/Dynamic/Registry.cpp
-@@ -240,6 +240,7 @@
-   REGISTER_MATCHER(enumDecl);
-   REGISTER_MATCHER(enumType);
-   REGISTER_MATCHER(equalsBoundNode);
-+  REGISTER_MATCHER(declaresSameEntityAsBoundNode);
-   REGISTER_MATCHER(equalsIntegralValue);
-   REGISTER_MATCHER(explicitCastExpr);
-   REGISTER_MATCHER(exportDecl);
 diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/SemaDecl.cpp
 --- a/clang/lib/Sema/SemaDecl.cpp
 +++ b/clang/lib/Sema/SemaDecl.cpp
-@@ -18028,7 +18028,8 @@
+@@ -18032,7 +18032,8 @@
            }
          }
        } else if (auto *RD = dyn_cast<CXXRecordDecl>(PrevDecl);
@@ -444,25 +412,7 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDecl.cpp b/clang/lib/Sema/Sem
 diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/SemaDeclCXX.cpp
 --- a/clang/lib/Sema/SemaDeclCXX.cpp
 +++ b/clang/lib/Sema/SemaDeclCXX.cpp
-@@ -1373,10 +1373,13 @@
-         S.BuildReferenceType(T, E.get()->isLValue(), Loc, B->getDeclName());
-     if (RefType.isNull())
-       return true;
--    auto *RefVD = VarDecl::Create(
--        S.Context, Src->getDeclContext(), Loc, Loc,
--        B->getDeclName().getAsIdentifierInfo(), RefType,
--        S.Context.getTrivialTypeSourceInfo(T, Loc), Src->getStorageClass());
-+
-+    // Don't give this VarDecl a TypeSourceInfo, since this is a synthesized
-+    // entity and this type was never written in source code.
-+    auto *RefVD =
-+        VarDecl::Create(S.Context, Src->getDeclContext(), Loc, Loc,
-+                        B->getDeclName().getAsIdentifierInfo(), RefType,
-+                        /*TInfo=*/nullptr, Src->getStorageClass());
-     RefVD->setLexicalDeclContext(Src->getLexicalDeclContext());
-     RefVD->setTSCSpec(Src->getTSCSpec());
-     RefVD->setImplicit();
-@@ -4565,6 +4568,7 @@
+@@ -4568,6 +4568,7 @@
        MarkAnyDeclReferenced(TyD->getLocation(), TyD, /*OdrUse=*/false);
  
        TypeLocBuilder TLB;
@@ -470,7 +420,7 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaDeclCXX.cpp b/clang/lib/Sema/
        if (const auto *TD = dyn_cast<TagDecl>(TyD)) {
          BaseType = Context.getTagType(ElaboratedTypeKeyword::None,
                                        SS.getScopeRep(), TD, /*OwnsTag=*/false);
-@@ -4578,6 +4582,12 @@
+@@ -4581,6 +4582,12 @@
          TLB.push<TypedefTypeLoc>(BaseType).set(
              /*ElaboratedKeywordLoc=*/SourceLocation(),
              SS.getWithLocInContext(Context), IdLoc);
@@ -645,13 +595,14 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/
      return getDerived().RebuildTemplateName(
          SubstPack->getArgumentPack(), SubstPack->getAssociatedDecl(),
          SubstPack->getIndex(), SubstPack->getFinal());
-@@ -5414,20 +5414,10 @@
+@@ -5414,21 +5414,10 @@
          TLB, TL.castAs<DependentNameTypeLoc>(), /*DeducedTSTContext=*/false,
          ObjectType, UnqualLookup);
    }
 -  case TypeLoc::Typedef:
 -  case TypeLoc::TemplateSpecialization:
 -  case TypeLoc::SubstTemplateTypeParm:
+-  case TypeLoc::SubstTemplateTypeParmPack:
 -  case TypeLoc::PackIndexing:
 -  case TypeLoc::Enum:
 -  case TypeLoc::Record:
@@ -669,20 +620,7 @@ diff -ruN --strip-trailing-cr a/clang/lib/Sema/TreeTransform.h b/clang/lib/Sema/
    }
  }
  
-@@ -7668,8 +7658,11 @@
-   } else if (isa<TypedefType>(Result)) {
-     TLB.push<TypedefTypeLoc>(Result).set(TL.getElaboratedKeywordLoc(),
-                                          QualifierLoc, TL.getNameLoc());
-+  } else if (isa<UnresolvedUsingType>(Result)) {
-+    auto NewTL = TLB.push<UnresolvedUsingTypeLoc>(Result);
-+    NewTL.set(TL.getElaboratedKeywordLoc(), QualifierLoc, TL.getNameLoc());
-   } else {
--    DependentNameTypeLoc NewTL = TLB.push<DependentNameTypeLoc>(Result);
-+    auto NewTL = TLB.push<DependentNameTypeLoc>(Result);
-     NewTL.setElaboratedKeywordLoc(TL.getElaboratedKeywordLoc());
-     NewTL.setQualifierLoc(QualifierLoc);
-     NewTL.setNameLoc(TL.getNameLoc());
-@@ -17364,13 +17357,12 @@
+@@ -17386,13 +17375,12 @@
    return SemaRef.BuildBitIntType(IsUnsigned, NumBitsExpr, Loc);
  }
  
@@ -726,24 +664,6 @@ diff -ruN --strip-trailing-cr a/clang/lib/Serialization/ASTReader.cpp b/clang/li
  
        diagnoseOdrViolations();
      }
-diff -ruN --strip-trailing-cr a/clang/test/Analysis/anonymous-decls.cpp b/clang/test/Analysis/anonymous-decls.cpp
---- a/clang/test/Analysis/anonymous-decls.cpp
-+++ b/clang/test/Analysis/anonymous-decls.cpp
-@@ -78,12 +78,12 @@
- // CHECK-NEXT:   8: decomposition-a-b
- // CHECK-NEXT:   9: [B3.7]([B3.8])
- // CHECK-NEXT:  10: [B3.9]
--// CHECK-NEXT:  11: std::tuple_element<0UL, std::pair<int, int>>::type a = get<0UL>(decomposition-a-b);
-+// CHECK-NEXT:  11: std::tuple_element<0UL, std::pair<int, int>>::type &&a = get<0UL>(decomposition-a-b);
- // CHECK-NEXT:  12: get<1UL>
- // CHECK-NEXT:  13: [B3.12] (ImplicitCastExpr, FunctionToPointerDecay, tuple_element<1L, pair<int, int> >::type (*)(pair<int, int> &))
- // CHECK-NEXT:  14: decomposition-a-b
- // CHECK-NEXT:  15: [B3.13]([B3.14])
- // CHECK-NEXT:  16: [B3.15]
--// CHECK-NEXT:  17: std::tuple_element<1UL, std::pair<int, int>>::type b = get<1UL>(decomposition-a-b);
-+// CHECK-NEXT:  17: std::tuple_element<1UL, std::pair<int, int>>::type &&b = get<1UL>(decomposition-a-b);
- // CHECK-NEXT:   Preds (1): B1
- // CHECK-NEXT:   Succs (1): B2
 diff -ruN --strip-trailing-cr a/clang/test/Analysis/ctu-import-type-decl-definition.c b/clang/test/Analysis/ctu-import-type-decl-definition.c
 --- a/clang/test/Analysis/ctu-import-type-decl-definition.c
 +++ b/clang/test/Analysis/ctu-import-type-decl-definition.c
@@ -1009,33 +929,6 @@ diff -ruN --strip-trailing-cr a/clang/test/Index/recursive-cxx-member-calls.cpp
  // CHECK: 87:35: ParmDecl=Str:87:35 (Definition) Extent=[87:25 - 87:38]
  // CHECK: 87:25: TypeRef=class llvm::StringRef:38:7 Extent=[87:25 - 87:34]
  // CHECK: 87:42: MemberRef=Str:84:13 Extent=[87:42 - 87:45]
-diff -ruN --strip-trailing-cr a/clang/test/Modules/GH153933.cpp b/clang/test/Modules/GH153933.cpp
---- a/clang/test/Modules/GH153933.cpp
-+++ b/clang/test/Modules/GH153933.cpp
-@@ -0,0 +1,23 @@
-+// RUN: rm -rf %t
-+// RUN: mkdir -p %t
-+// RUN: split-file %s %t
-+//
-+// RUN: %clang_cc1 -std=c++20 %t/B.cppm -emit-module-interface -o %t/B.pcm
-+// RUN: %clang_cc1 -std=c++20 -fsyntax-only -fprebuilt-module-path=%t %t/C.cpp
-+
-+//--- A.hpp
-+template<class> struct A {};
-+template<class T> struct B {
-+  virtual A<T> v() { return {}; }
-+};
-+B<void> x;
-+
-+//--- B.cppm
-+module;
-+#include "A.hpp"
-+export module B;
-+using ::x;
-+
-+//--- C.cpp
-+#include "A.hpp"
-+import B;
 diff -ruN --strip-trailing-cr a/clang/test/PCH/cxx-explicit-specifier.cpp b/clang/test/PCH/cxx-explicit-specifier.cpp
 --- a/clang/test/PCH/cxx-explicit-specifier.cpp
 +++ b/clang/test/PCH/cxx-explicit-specifier.cpp
@@ -1159,21 +1052,6 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/return.cpp b/clang/test/SemaC
                            // expected-error@-1 {{destructor '~ST' must not return void expression}}
    };
  
-diff -ruN --strip-trailing-cr a/clang/test/SemaCXX/using-decl-templates.cpp b/clang/test/SemaCXX/using-decl-templates.cpp
---- a/clang/test/SemaCXX/using-decl-templates.cpp
-+++ b/clang/test/SemaCXX/using-decl-templates.cpp
-@@ -153,3 +153,11 @@
- }
- } // namespace sss
- } // namespace func_templ
-+
-+namespace DependentName {
-+  template <typename T> struct S {
-+    using typename T::Ty;
-+    static Ty Val;
-+  };
-+  template <typename T> typename S<T>::Ty S<T>::Val;
-+} // DependentName
 diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/class-template-ctor-initializer.cpp b/clang/test/SemaTemplate/class-template-ctor-initializer.cpp
 --- a/clang/test/SemaTemplate/class-template-ctor-initializer.cpp
 +++ b/clang/test/SemaTemplate/class-template-ctor-initializer.cpp
@@ -1328,9 +1206,8 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/nested-name-spec-templat
 --- a/clang/test/SemaTemplate/nested-name-spec-template.cpp
 +++ b/clang/test/SemaTemplate/nested-name-spec-template.cpp
 @@ -1,5 +1,5 @@
--// RUN: %clang_cc1 -fsyntax-only -verify %s
+ // RUN: %clang_cc1 -fsyntax-only -verify %s -Wno-c++20-extensions
 -// RUN: %clang_cc1 -fsyntax-only -verify -std=c++98 %s
-+// RUN: %clang_cc1 -fsyntax-only -verify %s -Wno-c++20-extensions
 +// RUN: %clang_cc1 -fsyntax-only -verify -Wno-c++11-extensions -std=c++98 %s
  // RUN: %clang_cc1 -fsyntax-only -verify -std=c++11 %s
  
@@ -1350,24 +1227,10 @@ diff -ruN --strip-trailing-cr a/clang/test/SemaTemplate/nested-name-spec-templat
  }
  
  N::M::Promote<int>::type *ret_intptr5(int* ip) { return ip; }
-@@ -167,3 +160,53 @@
-   };
-   template struct C<int>;
- } // namespace unresolved_using
-+
-+#if __cplusplus >= 201703L
-+namespace SubstTemplateTypeParmPackType {
-+  template <int...> struct A {};
-+
-+  template <class... Ts> void f() {
-+    []<int ... Is>(A<Is...>) { (Ts::g(Is) && ...); }(A<0>{});
-+  };
-+
-+  struct B { static void g(int); };
-+
-+  template void f<B>();
-+} // namespace SubstTemplateTypeParmPackType
-+#endif
+@@ -181,3 +174,39 @@
+   template void f<B>();
+ } // namespace SubstTemplateTypeParmPackType
+ #endif
 +
 +namespace DependentUnaryTransform {
 +  template <class T> using decay_t = __decay(T);
@@ -1427,60 +1290,6 @@ diff -ruN --strip-trailing-cr a/clang/unittests/AST/DeclTest.cpp b/clang/unittes
 +  ASSERT_NE(FD, nullptr);
 +  ASSERT_EQ(FD->getQualifiedNameAsString(), "x::y::Foo::Foo<T>");
 +}
-diff -ruN --strip-trailing-cr a/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp b/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp
---- a/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp
-+++ b/clang-tools-extra/clang-tidy/misc/UnconventionalAssignOperatorCheck.cpp
-@@ -29,11 +29,13 @@
-   const auto HasGoodReturnType =
-       cxxMethodDecl(returns(hasCanonicalType(lValueReferenceType(pointee(
-           unless(isConstQualified()),
--          anyOf(autoType(), hasDeclaration(equalsBoundNode("class"))))))));
-+          anyOf(autoType(),
-+                hasDeclaration(declaresSameEntityAsBoundNode("class"))))))));
- 
-   const auto IsSelf = qualType(hasCanonicalType(
--      anyOf(hasDeclaration(equalsBoundNode("class")),
--            referenceType(pointee(hasDeclaration(equalsBoundNode("class")))))));
-+      anyOf(hasDeclaration(declaresSameEntityAsBoundNode("class")),
-+            referenceType(pointee(
-+                hasDeclaration(declaresSameEntityAsBoundNode("class")))))));
-   const auto IsAssign =
-       cxxMethodDecl(unless(anyOf(isDeleted(), isPrivate(), isImplicit())),
-                     hasName("operator="), ofClass(recordDecl().bind("class")))
-diff -ruN --strip-trailing-cr a/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp b/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp
---- a/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp
-+++ b/clang-tools-extra/test/clang-tidy/checkers/misc/unconventional-assign-operator.cpp
-@@ -176,3 +176,11 @@
-   }
- };
- }
-+
-+namespace GH153770 {
-+  struct A;
-+  struct A {
-+    A() = default;
-+    A& operator=(const A&) = default;
-+  };
-+} // namespace GH153770
-diff -ruN --strip-trailing-cr a/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp b/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp
---- a/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp
-+++ b/clang-tools-extra/test/clang-tidy/checkers/modernize/type-traits-GH153649.cpp
-@@ -0,0 +1,15 @@
-+// RUN: %check_clang_tidy -std=c++20 %s modernize-type-traits %t
-+
-+namespace std {
-+template <class> struct tuple_size {
-+  static const int value = 1;
-+};
-+template <int, class> struct tuple_element {
-+  using type = int;
-+};
-+}
-+
-+struct A {};
-+template <int> int get(const A&);
-+
-+auto [a] = A();
 diff -ruN --strip-trailing-cr a/libcxx/include/tuple b/libcxx/include/tuple
 --- a/libcxx/include/tuple
 +++ b/libcxx/include/tuple
@@ -1722,132 +1531,181 @@ diff -ruN --strip-trailing-cr a/lldb/source/Plugins/SymbolFile/NativePDB/SymbolF
  
    // Now that we know the forward -> full mapping of all type indices, we can
    // re-write all the indices.  At the end of this process, we want a mapping
-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
---- a/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
-+++ b/llvm/lib/Transforms/Vectorize/LoopVectorize.cpp
-@@ -9786,6 +9786,19 @@
-                "Must only have a single non-zero incoming value");
-         EPI.VectorTripCount = Inc;
-       }
-+      // If we didn't find a non-zero vector trip count, all incoming values
-+      // must be zero, which also means the vector trip count is zero. Pick the
-+      // first zero as vector trip count.
-+      // TODO: We should not choose VF * UF so the main vector loop is known to
-+      // be dead.
-+      if (!EPI.VectorTripCount) {
-+        assert(
-+            EPResumeVal->getNumIncomingValues() > 0 &&
-+            all_of(EPResumeVal->incoming_values(),
-+                   [](Value *Inc) { return match(Inc, m_SpecificInt(0)); }) &&
-+            "all incoming values must be 0");
-+        EPI.VectorTripCount = EPResumeVal->getOperand(0);
-+      }
-       VPValue *VPV = Plan.getOrAddLiveIn(EPResumeVal);
-       assert(all_of(IV->users(),
-                     [](const VPUser *U) {
-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll b/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll
---- a/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll
-+++ b/llvm/test/Transforms/LoopVectorize/AArch64/epilog-vectorization-factors.ll
-@@ -333,3 +333,91 @@
- exit:
-   ret void
+diff -ruN --strip-trailing-cr a/mlir/include/mlir/AsmParser/AsmParser.h b/mlir/include/mlir/AsmParser/AsmParser.h
+--- a/mlir/include/mlir/AsmParser/AsmParser.h
++++ b/mlir/include/mlir/AsmParser/AsmParser.h
+@@ -53,8 +53,7 @@
+ /// null terminated.
+ Attribute parseAttribute(llvm::StringRef attrStr, MLIRContext *context,
+                          Type type = {}, size_t *numRead = nullptr,
+-                         bool isKnownNullTerminated = false,
+-                         llvm::StringMap<Attribute> *attributesCache = nullptr);
++                         bool isKnownNullTerminated = false);
+ 
+ /// This parses a single MLIR type to an MLIR context if it was valid. If not,
+ /// an error diagnostic is emitted to the context.
+diff -ruN --strip-trailing-cr a/mlir/lib/AsmParser/DialectSymbolParser.cpp b/mlir/lib/AsmParser/DialectSymbolParser.cpp
+--- a/mlir/lib/AsmParser/DialectSymbolParser.cpp
++++ b/mlir/lib/AsmParser/DialectSymbolParser.cpp
+@@ -245,15 +245,6 @@
+       return nullptr;
+   }
+ 
+-  if constexpr (std::is_same_v<Symbol, Attribute>) {
+-    auto &cache = p.getState().symbols.attributesCache;
+-    auto cacheIt = cache.find(symbolData);
+-    // Skip cached attribute if it has type.
+-    if (cacheIt != cache.end() && !p.getToken().is(Token::colon))
+-      return cacheIt->second;
+-
+-    return cache[symbolData] = createSymbol(dialectName, symbolData, loc);
+-  }
+   return createSymbol(dialectName, symbolData, loc);
  }
-+
-+; TODO: Choose smaller VF * UF for main loop, so we do not create a dead vector loop.
-+define void @small_trip_count_loop(ptr %arg, ptr %arg2) {
-+; CHECK-LABEL: @small_trip_count_loop(
-+; CHECK-NEXT:  iter.check:
-+; CHECK-NEXT:    [[ARG3:%.*]] = ptrtoint ptr [[ARG:%.*]] to i64
-+; CHECK-NEXT:    [[ARG21:%.*]] = ptrtoint ptr [[ARG2:%.*]] to i64
-+; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_SCALAR_PH:%.*]], label [[VECTOR_MEMCHECK:%.*]]
-+; CHECK:       vector.memcheck:
-+; CHECK-NEXT:    [[TMP0:%.*]] = sub i64 [[ARG21]], [[ARG3]]
-+; CHECK-NEXT:    [[DIFF_CHECK:%.*]] = icmp ult i64 [[TMP0]], 64
-+; CHECK-NEXT:    br i1 [[DIFF_CHECK]], label [[VEC_EPILOG_SCALAR_PH]], label [[VECTOR_MAIN_LOOP_ITER_CHECK:%.*]]
-+; CHECK:       vector.main.loop.iter.check:
-+; CHECK-NEXT:    br i1 true, label [[VEC_EPILOG_PH:%.*]], label [[VECTOR_PH:%.*]]
-+; CHECK:       vector.ph:
-+; CHECK-NEXT:    br label [[VECTOR_BODY:%.*]]
-+; CHECK:       vector.body:
-+; CHECK-NEXT:    [[TMP1:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 16
-+; CHECK-NEXT:    [[TMP2:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 32
-+; CHECK-NEXT:    [[TMP3:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 48
-+; CHECK-NEXT:    [[WIDE_LOAD:%.*]] = load <16 x i8>, ptr [[ARG]], align 1
-+; CHECK-NEXT:    [[WIDE_LOAD4:%.*]] = load <16 x i8>, ptr [[TMP1]], align 1
-+; CHECK-NEXT:    [[WIDE_LOAD5:%.*]] = load <16 x i8>, ptr [[TMP2]], align 1
-+; CHECK-NEXT:    [[WIDE_LOAD6:%.*]] = load <16 x i8>, ptr [[TMP3]], align 1
-+; CHECK-NEXT:    [[TMP4:%.*]] = add <16 x i8> [[WIDE_LOAD]], splat (i8 10)
-+; CHECK-NEXT:    [[TMP5:%.*]] = add <16 x i8> [[WIDE_LOAD4]], splat (i8 10)
-+; CHECK-NEXT:    [[TMP6:%.*]] = add <16 x i8> [[WIDE_LOAD5]], splat (i8 10)
-+; CHECK-NEXT:    [[TMP7:%.*]] = add <16 x i8> [[WIDE_LOAD6]], splat (i8 10)
-+; CHECK-NEXT:    [[TMP8:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 16
-+; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 32
-+; CHECK-NEXT:    [[TMP10:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 48
-+; CHECK-NEXT:    store <16 x i8> [[TMP4]], ptr [[ARG2]], align 1
-+; CHECK-NEXT:    store <16 x i8> [[TMP5]], ptr [[TMP8]], align 1
-+; CHECK-NEXT:    store <16 x i8> [[TMP6]], ptr [[TMP9]], align 1
-+; CHECK-NEXT:    store <16 x i8> [[TMP7]], ptr [[TMP10]], align 1
-+; CHECK-NEXT:    br label [[MIDDLE_BLOCK:%.*]]
-+; CHECK:       middle.block:
-+; CHECK-NEXT:    br i1 false, label [[EXIT:%.*]], label [[VEC_EPILOG_ITER_CHECK:%.*]]
-+; CHECK:       vec.epilog.iter.check:
-+; CHECK-NEXT:    br i1 false, label [[VEC_EPILOG_SCALAR_PH]], label [[VEC_EPILOG_PH]]
-+; CHECK:       vec.epilog.ph:
-+; CHECK-NEXT:    [[VEC_EPILOG_RESUME_VAL:%.*]] = phi i32 [ 0, [[VEC_EPILOG_ITER_CHECK]] ], [ 0, [[VECTOR_MAIN_LOOP_ITER_CHECK]] ]
-+; CHECK-NEXT:    br label [[VEC_EPILOG_VECTOR_BODY:%.*]]
-+; CHECK:       vec.epilog.vector.body:
-+; CHECK-NEXT:    [[INDEX:%.*]] = phi i32 [ [[VEC_EPILOG_RESUME_VAL]], [[VEC_EPILOG_PH]] ], [ [[INDEX_NEXT:%.*]], [[VEC_EPILOG_VECTOR_BODY]] ]
-+; CHECK-NEXT:    [[TMP11:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 [[INDEX]]
-+; CHECK-NEXT:    [[WIDE_LOAD7:%.*]] = load <16 x i8>, ptr [[TMP11]], align 1
-+; CHECK-NEXT:    [[TMP12:%.*]] = add <16 x i8> [[WIDE_LOAD7]], splat (i8 10)
-+; CHECK-NEXT:    [[TMP13:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 [[INDEX]]
-+; CHECK-NEXT:    store <16 x i8> [[TMP12]], ptr [[TMP13]], align 1
-+; CHECK-NEXT:    [[INDEX_NEXT]] = add nuw i32 [[INDEX]], 16
-+; CHECK-NEXT:    [[TMP14:%.*]] = icmp eq i32 [[INDEX_NEXT]], 16
-+; CHECK-NEXT:    br i1 [[TMP14]], label [[VEC_EPILOG_MIDDLE_BLOCK:%.*]], label [[VEC_EPILOG_VECTOR_BODY]], !llvm.loop [[LOOP11:![0-9]+]]
-+; CHECK:       vec.epilog.middle.block:
-+; CHECK-NEXT:    br i1 false, label [[EXIT]], label [[VEC_EPILOG_SCALAR_PH]]
-+; CHECK:       vec.epilog.scalar.ph:
-+; CHECK-NEXT:    [[BC_RESUME_VAL:%.*]] = phi i32 [ 16, [[VEC_EPILOG_MIDDLE_BLOCK]] ], [ 0, [[VEC_EPILOG_ITER_CHECK]] ], [ 0, [[VECTOR_MEMCHECK]] ], [ 0, [[ITER_CHECK:%.*]] ]
-+; CHECK-NEXT:    br label [[LOOP:%.*]]
-+; CHECK:       loop:
-+; CHECK-NEXT:    [[IV:%.*]] = phi i32 [ [[BC_RESUME_VAL]], [[VEC_EPILOG_SCALAR_PH]] ], [ [[IV_NEXT:%.*]], [[LOOP]] ]
-+; CHECK-NEXT:    [[GEP_A:%.*]] = getelementptr inbounds i8, ptr [[ARG]], i32 [[IV]]
-+; CHECK-NEXT:    [[LOAD:%.*]] = load i8, ptr [[GEP_A]], align 1
-+; CHECK-NEXT:    [[SELECT:%.*]] = add i8 [[LOAD]], 10
-+; CHECK-NEXT:    [[GEP_B:%.*]] = getelementptr inbounds i8, ptr [[ARG2]], i32 [[IV]]
-+; CHECK-NEXT:    store i8 [[SELECT]], ptr [[GEP_B]], align 1
-+; CHECK-NEXT:    [[IV_NEXT]] = add i32 [[IV]], 1
-+; CHECK-NEXT:    [[EC:%.*]] = icmp eq i32 [[IV]], 20
-+; CHECK-NEXT:    br i1 [[EC]], label [[EXIT]], label [[LOOP]], !llvm.loop [[LOOP12:![0-9]+]]
-+; CHECK:       exit:
-+; CHECK-NEXT:    ret void
-+;
-+entry:
-+  br label %loop
-+
-+loop:
-+  %iv = phi i32 [ 0, %entry ], [ %iv.next, %loop ]
-+  %gep.A = getelementptr inbounds i8, ptr %arg, i32 %iv
-+  %load = load i8, ptr %gep.A, align 1
-+  %select = add i8 %load, 10
-+  %gep.B = getelementptr inbounds i8, ptr %arg2, i32 %iv
-+  store i8 %select, ptr %gep.B, align 1
-+  %iv.next = add i32 %iv, 1
-+  %ec = icmp eq i32 %iv, 20
-+  br i1 %ec, label %exit, label %loop
-+
-+exit:
-+  ret void
-+}
-diff -ruN --strip-trailing-cr a/llvm/tools/llvm-c-test/debuginfo.c b/llvm/tools/llvm-c-test/debuginfo.c
---- a/llvm/tools/llvm-c-test/debuginfo.c
-+++ b/llvm/tools/llvm-c-test/debuginfo.c
-@@ -448,6 +448,7 @@
-   assert(ME != NULL);
-   assert(numEntries == 2);
- 
-+  LLVMDisposeValueMetadataEntries(ME);
-   LLVMDisposeDIBuilder(Builder);
-   LLVMDisposeModule(M);
+ 
+@@ -346,7 +337,6 @@
+ template <typename T, typename ParserFn>
+ static T parseSymbol(StringRef inputStr, MLIRContext *context,
+                      size_t *numReadOut, bool isKnownNullTerminated,
+-                     llvm::StringMap<Attribute> *attributesCache,
+                      ParserFn &&parserFn) {
+   // Set the buffer name to the string being parsed, so that it appears in error
+   // diagnostics.
+@@ -358,9 +348,6 @@
+   SourceMgr sourceMgr;
+   sourceMgr.AddNewSourceBuffer(std::move(memBuffer), SMLoc());
+   SymbolState aliasState;
+-  if (attributesCache)
+-    aliasState.attributesCache = *attributesCache;
+-
+   ParserConfig config(context);
+   ParserState state(sourceMgr, config, aliasState, /*asmState=*/nullptr,
+                     /*codeCompleteContext=*/nullptr);
+@@ -371,11 +358,6 @@
+   if (!symbol)
+     return T();
+ 
+-  if constexpr (std::is_same_v<T, Attribute>) {
+-    if (attributesCache)
+-      *attributesCache = state.symbols.attributesCache;
+-  }
+-
+   // Provide the number of bytes that were read.
+   Token endTok = parser.getToken();
+   size_t numRead =
+@@ -392,15 +374,13 @@
+ 
+ Attribute mlir::parseAttribute(StringRef attrStr, MLIRContext *context,
+                                Type type, size_t *numRead,
+-                               bool isKnownNullTerminated,
+-                               llvm::StringMap<Attribute> *attributesCache) {
++                               bool isKnownNullTerminated) {
+   return parseSymbol<Attribute>(
+-      attrStr, context, numRead, isKnownNullTerminated, attributesCache,
++      attrStr, context, numRead, isKnownNullTerminated,
+       [type](Parser &parser) { return parser.parseAttribute(type); });
+ }
+ Type mlir::parseType(StringRef typeStr, MLIRContext *context, size_t *numRead,
+                      bool isKnownNullTerminated) {
+   return parseSymbol<Type>(typeStr, context, numRead, isKnownNullTerminated,
+-                           /*attributesCache=*/nullptr,
+                            [](Parser &parser) { return parser.parseType(); });
+ }
+diff -ruN --strip-trailing-cr a/mlir/lib/AsmParser/ParserState.h b/mlir/lib/AsmParser/ParserState.h
+--- a/mlir/lib/AsmParser/ParserState.h
++++ b/mlir/lib/AsmParser/ParserState.h
+@@ -40,9 +40,6 @@
+ 
+   /// A map from unique integer identifier to DistinctAttr.
+   DenseMap<uint64_t, DistinctAttr> distinctAttributes;
+-
+-  /// A map from unique string identifier to Attribute.
+-  llvm::StringMap<Attribute> attributesCache;
+ };
+ 
+ //===----------------------------------------------------------------------===//
+diff -ruN --strip-trailing-cr a/mlir/lib/Bytecode/Reader/BytecodeReader.cpp b/mlir/lib/Bytecode/Reader/BytecodeReader.cpp
+--- a/mlir/lib/Bytecode/Reader/BytecodeReader.cpp
++++ b/mlir/lib/Bytecode/Reader/BytecodeReader.cpp
+@@ -895,10 +895,6 @@
+   SmallVector<AttrEntry> attributes;
+   SmallVector<TypeEntry> types;
+ 
+-  /// The map of cached attributes, used to avoid re-parsing the same
+-  /// attribute multiple times.
+-  llvm::StringMap<Attribute> attributesCache;
+-
+   /// A location used for error emission.
+   Location fileLoc;
+ 
+@@ -1239,7 +1235,7 @@
+         ::parseType(asmStr, context, &numRead, /*isKnownNullTerminated=*/true);
+   else
+     result = ::parseAttribute(asmStr, context, Type(), &numRead,
+-                              /*isKnownNullTerminated=*/true, &attributesCache);
++                              /*isKnownNullTerminated=*/true);
+   if (!result)
+     return failure();
+ 
+diff -ruN --strip-trailing-cr a/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp b/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp
+--- a/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp
++++ b/mlir/lib/Conversion/GPUCommon/GPUToLLVMConversion.cpp
+@@ -532,6 +532,9 @@
+     // Vector transfer ops with rank > 1 should be lowered with VectorToSCF.
+     vector::populateVectorTransferLoweringPatterns(patterns,
+                                                    /*maxTransferRank=*/1);
++    // Transform N-D vector.from_elements to 1-D vector.from_elements before
++    // conversion.
++    vector::populateVectorFromElementsLoweringPatterns(patterns);
+     if (failed(applyPatternsGreedily(getOperation(), std::move(patterns))))
+       return signalPassFailure();
+   }
+diff -ruN --strip-trailing-cr a/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp b/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp
+--- a/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp
++++ b/mlir/lib/Conversion/GPUToNVVM/LowerGpuOpsToNVVMOps.cpp
+@@ -27,6 +27,7 @@
+ #include "mlir/Dialect/Math/IR/Math.h"
+ #include "mlir/Dialect/MemRef/IR/MemRef.h"
+ #include "mlir/Dialect/NVGPU/IR/NVGPUDialect.h"
++#include "mlir/Dialect/Vector/Transforms/LoweringPatterns.h"
+ #include "mlir/Transforms/DialectConversion.h"
+ #include "mlir/Transforms/GreedyPatternRewriteDriver.h"
+ 
+@@ -369,6 +370,9 @@
+     {
+       RewritePatternSet patterns(m.getContext());
+       populateGpuRewritePatterns(patterns);
++      // Transform N-D vector.from_elements to 1-D vector.from_elements before
++      // conversion.
++      vector::populateVectorFromElementsLoweringPatterns(patterns);
+       if (failed(applyPatternsGreedily(m, std::move(patterns))))
+         return signalPassFailure();
+     }
+diff -ruN --strip-trailing-cr a/mlir/test/IR/recursive-distinct-attr.mlir b/mlir/test/IR/recursive-distinct-attr.mlir
+--- a/mlir/test/IR/recursive-distinct-attr.mlir
++++ b/mlir/test/IR/recursive-distinct-attr.mlir
+@@ -1,13 +0,0 @@
+-// RUN: mlir-opt -emit-bytecode %s | mlir-opt --mlir-print-debuginfo | FileCheck %s
+-
+-// Verify that the distinct attribute which is used transitively
+-// through two aliases does not end up duplicated when round-tripped
+-// through bytecode.
+-
+-// CHECK: distinct[0]
+-// CHECK-NOT: distinct[1]
+-#attr_ugly = #test<attr_ugly begin distinct[0]<> end>
+-#attr_ugly1 = #test<attr_ugly begin #attr_ugly end>
+-
+-module attributes {test.alias = #attr_ugly, test.alias1 = #attr_ugly1} {
+-}
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+--- a/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
++++ b/utils/bazel/llvm-project-overlay/mlir/BUILD.bazel
+@@ -5718,6 +5718,7 @@
+         ":NVGPUDialect",
+         ":NVVMDialect",
+         ":TransformUtils",
++        ":VectorTransforms",
+     ],
+ )
  
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index ed69d9f..8bcb8f9 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "cb2f0d0a5f14c183e7182aba0f0e54a518de9e3f"
-    LLVM_SHA256 = "e8ece380fdb57dc6f8e42df9db872a1ade5056c5379075e3e2f99c89200aea69"
+    LLVM_COMMIT = "a6da68ed36d7ecb9edf00262d2a2c1129689399f"
+    LLVM_SHA256 = "a5ba622b3a1342fdb763dfa29e1cd70838731932a8cc662fcac4910d67048613"
 
     tf_http_archive(
         name = name,
