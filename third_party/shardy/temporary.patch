diff --git a/third_party/llvm/generated.patch b/third_party/llvm/generated.patch
index 7725bb5..6282db8 100644
--- a/third_party/llvm/generated.patch
+++ b/third_party/llvm/generated.patch
@@ -1,1241 +1,918 @@
 Auto generated patch. Do not edit or delete it, even if empty.
-diff -ruN --strip-trailing-cr a/clang/lib/Sema/SemaChecking.cpp b/clang/lib/Sema/SemaChecking.cpp
---- a/clang/lib/Sema/SemaChecking.cpp
-+++ b/clang/lib/Sema/SemaChecking.cpp
-@@ -6149,18 +6149,19 @@
-             if (!Sema::getFormatStringInfo(D, PVFormat->getFormatIdx(),
-                                            PVFormat->getFirstArg(), &CallerFSI))
-               continue;
--            // We also check if the formats are compatible.
--            // We can't pass a 'scanf' string to a 'printf' function.
--            if (Type != S.GetFormatStringType(PVFormat)) {
--              S.Diag(Args[format_idx]->getBeginLoc(),
--                     diag::warn_format_string_type_incompatible)
--                  << PVFormat->getType()->getName()
--                  << S.GetFormatStringTypeName(Type);
--              if (!InFunctionCall) {
--                S.Diag(E->getBeginLoc(), diag::note_format_string_defined);
-+            if (PV->getFunctionScopeIndex() == CallerFSI.FormatIdx) {
-+              // We also check if the formats are compatible.
-+              // We can't pass a 'scanf' string to a 'printf' function.
-+              if (Type != S.GetFormatStringType(PVFormat)) {
-+                S.Diag(Args[format_idx]->getBeginLoc(),
-+                       diag::warn_format_string_type_incompatible)
-+                    << PVFormat->getType()->getName()
-+                    << S.GetFormatStringTypeName(Type);
-+                if (!InFunctionCall) {
-+                  S.Diag(E->getBeginLoc(), diag::note_format_string_defined);
-+                }
-+                return SLCT_UncheckedLiteral;
-               }
--              return SLCT_UncheckedLiteral;
--            } else if (PV->getFunctionScopeIndex() == CallerFSI.FormatIdx) {
-               // Lastly, check that argument passing kinds transition in a
-               // way that makes sense:
-               // from a caller with FAPK_VAList, allow FAPK_VAList
-diff -ruN --strip-trailing-cr a/clang/test/Sema/format-strings.c b/clang/test/Sema/format-strings.c
---- a/clang/test/Sema/format-strings.c
-+++ b/clang/test/Sema/format-strings.c
-@@ -496,6 +496,26 @@
-   rdar8332221_vprintf_scanf("%", ap, "%d", x); // expected-warning{{incomplete format specifier}}
- }
+diff -ruN --strip-trailing-cr a/libcxx/docs/ReleaseNotes/20.rst b/libcxx/docs/ReleaseNotes/20.rst
+--- a/libcxx/docs/ReleaseNotes/20.rst
++++ b/libcxx/docs/ReleaseNotes/20.rst
+@@ -120,8 +120,6 @@
  
-+void rdar8332221_vprintf_scanf(const char *p, va_list ap, const char *s, ...) {
-+  vprintf(p, ap);
-+
-+  va_list vs;
-+  va_start(vs, s);
-+  vscanf(s, vs);
-+  va_end(vs);
-+}
-+
-+__attribute__((__format__(__printf__, 1, 0)))
-+__attribute__((__format__(__scanf__, 3, 4)))
-+void vprintf_scanf_bad(const char *p, va_list ap, const char *s, ...) {
-+  vscanf(p, ap); // expected-warning{{passing 'printf' format string where 'scanf' format string is expected}}
+ - Added :ref:`hardening mode <hardening>` support for ``forward_list`` and ``bitset``.
+ 
+-- The ``num_get::do_put`` integral overloads have been optimized, resulting in a performance improvement of up to 2.4x.
+-
+ Deprecations and Removals
+ -------------------------
+ 
+diff -ruN --strip-trailing-cr a/libcxx/include/__charconv/tables.h b/libcxx/include/__charconv/tables.h
+--- a/libcxx/include/__charconv/tables.h
++++ b/libcxx/include/__charconv/tables.h
+@@ -19,14 +19,16 @@
+ 
+ _LIBCPP_BEGIN_NAMESPACE_STD
+ 
++#if _LIBCPP_STD_VER >= 17
 +
-+  va_list vs;
-+  va_start(vs, s);
-+  vprintf(s, vs); // expected-warning{{passing 'scanf' format string where 'printf' format string is expected}}
-+  va_end(vs);
-+}
+ namespace __itoa {
+ 
+-inline _LIBCPP_CONSTEXPR const char __base_2_lut[64] = {
++inline constexpr char __base_2_lut[64] = {
+     '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '1', '0', '0', '0', '1', '1', '0', '1', '0', '0', '0', '1',
+     '0', '1', '0', '1', '1', '0', '0', '1', '1', '1', '1', '0', '0', '0', '1', '0', '0', '1', '1', '0', '1', '0',
+     '1', '0', '1', '1', '1', '1', '0', '0', '1', '1', '0', '1', '1', '1', '1', '0', '1', '1', '1', '1'};
+ 
+-inline _LIBCPP_CONSTEXPR const char __base_8_lut[128] = {
++inline constexpr char __base_8_lut[128] = {
+     '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0', '7', '1', '0', '1', '1', '1', '2',
+     '1', '3', '1', '4', '1', '5', '1', '6', '1', '7', '2', '0', '2', '1', '2', '2', '2', '3', '2', '4', '2', '5',
+     '2', '6', '2', '7', '3', '0', '3', '1', '3', '2', '3', '3', '3', '4', '3', '5', '3', '6', '3', '7', '4', '0',
+@@ -34,7 +36,7 @@
+     '5', '4', '5', '5', '5', '6', '5', '7', '6', '0', '6', '1', '6', '2', '6', '3', '6', '4', '6', '5', '6', '6',
+     '6', '7', '7', '0', '7', '1', '7', '2', '7', '3', '7', '4', '7', '5', '7', '6', '7', '7'};
+ 
+-inline _LIBCPP_CONSTEXPR const char __base_16_lut[512] = {
++inline constexpr char __base_16_lut[512] = {
+     '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0', '7', '0', '8', '0', '9', '0', 'a', '0',
+     'b', '0', 'c', '0', 'd', '0', 'e', '0', 'f', '1', '0', '1', '1', '1', '2', '1', '3', '1', '4', '1', '5', '1', '6',
+     '1', '7', '1', '8', '1', '9', '1', 'a', '1', 'b', '1', 'c', '1', 'd', '1', 'e', '1', 'f', '2', '0', '2', '1', '2',
+@@ -59,7 +61,7 @@
+     '1', 'f', '2', 'f', '3', 'f', '4', 'f', '5', 'f', '6', 'f', '7', 'f', '8', 'f', '9', 'f', 'a', 'f', 'b', 'f', 'c',
+     'f', 'd', 'f', 'e', 'f', 'f'};
+ 
+-inline _LIBCPP_CONSTEXPR const uint32_t __pow10_32[10] = {
++inline constexpr uint32_t __pow10_32[10] = {
+     UINT32_C(0),
+     UINT32_C(10),
+     UINT32_C(100),
+@@ -71,7 +73,7 @@
+     UINT32_C(100000000),
+     UINT32_C(1000000000)};
+ 
+-inline _LIBCPP_CONSTEXPR const uint64_t __pow10_64[20] = {
++inline constexpr uint64_t __pow10_64[20] = {
+     UINT64_C(0),
+     UINT64_C(10),
+     UINT64_C(100),
+@@ -94,8 +96,8 @@
+     UINT64_C(10000000000000000000)};
+ 
+ #  if _LIBCPP_HAS_INT128
+-inline _LIBCPP_CONSTEXPR const int __pow10_128_offset      = 0;
+-inline _LIBCPP_CONSTEXPR const __uint128_t __pow10_128[40] = {
++inline constexpr int __pow10_128_offset      = 0;
++inline constexpr __uint128_t __pow10_128[40] = {
+     UINT64_C(0),
+     UINT64_C(10),
+     UINT64_C(100),
+@@ -138,7 +140,7 @@
+     (__uint128_t(UINT64_C(10000000000000000000)) * UINT64_C(10000000000000000000)) * 10};
+ #  endif
+ 
+-inline _LIBCPP_CONSTEXPR const char __digits_base_10[200] = {
++inline constexpr char __digits_base_10[200] = {
+     // clang-format off
+     '0', '0', '0', '1', '0', '2', '0', '3', '0', '4', '0', '5', '0', '6', '0', '7', '0', '8', '0', '9',
+     '1', '0', '1', '1', '1', '2', '1', '3', '1', '4', '1', '5', '1', '6', '1', '7', '1', '8', '1', '9',
+@@ -154,6 +156,8 @@
+ 
+ } // namespace __itoa
+ 
++#endif // _LIBCPP_STD_VER >= 17
 +
- // PR8641
- void pr8641(void) {
-   printf("%#x\n", 10);
-diff -ruN --strip-trailing-cr a/llvm/lib/CodeGen/SplitKit.cpp b/llvm/lib/CodeGen/SplitKit.cpp
---- a/llvm/lib/CodeGen/SplitKit.cpp
-+++ b/llvm/lib/CodeGen/SplitKit.cpp
-@@ -598,25 +598,27 @@
-   if (!UseMI)
-     return false;
- 
--  Register Reg = Edit->getReg();
--  const TargetRegisterClass *RC = MRI.getRegClass(Reg);
-+  // Currently code assumes rematerialization only happens for a def at 0.
-+  const unsigned DefOperandIdx = 0;
-+  // We want to compute the static register class constraint for the instruction
-+  // def. If it is a smaller subclass than getLargestLegalSuperClass at the use
-+  // site, then rematerializing it will increase the constraints.
-+  const TargetRegisterClass *DefConstrainRC =
-+      DefMI->getRegClassConstraint(DefOperandIdx, &TII, &TRI);
-+  if (!DefConstrainRC)
-+    return false;
+ _LIBCPP_END_NAMESPACE_STD
+ 
+ #endif // _LIBCPP___CHARCONV_TABLES
+diff -ruN --strip-trailing-cr a/libcxx/include/__charconv/to_chars_base_10.h b/libcxx/include/__charconv/to_chars_base_10.h
+--- a/libcxx/include/__charconv/to_chars_base_10.h
++++ b/libcxx/include/__charconv/to_chars_base_10.h
+@@ -26,53 +26,55 @@
+ 
+ _LIBCPP_BEGIN_NAMESPACE_STD
+ 
++#if _LIBCPP_STD_VER >= 17
 +
-+  const TargetRegisterClass *RC = MRI.getRegClass(Edit->getReg());
- 
-   // We want to find the register class that can be inflated to after the split
-   // occurs in recomputeRegClass
-   const TargetRegisterClass *SuperRC =
-       TRI.getLargestLegalSuperClass(RC, *MBB.getParent());
- 
--  // We want to compute the static register class constraint for the instruction
--  // def. If it is a smaller subclass than getLargestLegalSuperClass at the use
--  // site, then rematerializing it will increase the constraints.
--  const TargetRegisterClass *DefConstrainRC =
--      DefMI->getRegClassConstraintEffectForVReg(Reg, SuperRC, &TII, &TRI,
--                                                /*ExploreBundle=*/true);
--
-+  Register DefReg = DefMI->getOperand(DefOperandIdx).getReg();
-   const TargetRegisterClass *UseConstrainRC =
--      UseMI->getRegClassConstraintEffectForVReg(Reg, SuperRC, &TII, &TRI,
-+      UseMI->getRegClassConstraintEffectForVReg(DefReg, SuperRC, &TII, &TRI,
-                                                 /*ExploreBundle=*/true);
--
-   return UseConstrainRC->hasSubClass(DefConstrainRC);
+ namespace __itoa {
+ 
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append1(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append1(char* __first, uint32_t __value) noexcept {
+   *__first = '0' + static_cast<char>(__value);
+   return __first + 1;
  }
  
-diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
---- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
-+++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
-@@ -13585,6 +13585,15 @@
-           UserPHI ? UserPHI->getIncomingBlock(UseEI.EdgeIdx)->getTerminator()
-                   : &getLastInstructionInBundle(UseEI.UserTE);
-       if (TEInsertPt == InsertPt) {
-+        // If the users are the PHI nodes with the same incoming blocks - skip.
-+        if (TEUseEI.UserTE->State == TreeEntry::Vectorize &&
-+            TEUseEI.UserTE->getOpcode() == Instruction::PHI &&
-+            UseEI.UserTE->State == TreeEntry::Vectorize &&
-+            UseEI.UserTE->getOpcode() == Instruction::PHI &&
-+            TEUseEI.UserTE != UseEI.UserTE &&
-+            TEUseEI.UserTE->getMainOp()->getParent() ==
-+                UseEI.UserTE->getMainOp()->getParent())
-+          continue;
-         // If 2 gathers are operands of the same entry (regardless of whether
-         // user is PHI or else), compare operands indices, use the earlier one
-         // as the base.
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/ARM/splitkit.ll b/llvm/test/CodeGen/ARM/splitkit.ll
---- a/llvm/test/CodeGen/ARM/splitkit.ll
-+++ b/llvm/test/CodeGen/ARM/splitkit.ll
-@@ -94,7 +94,7 @@
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append2(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append2(char* __first, uint32_t __value) noexcept {
+   return std::copy_n(&__digits_base_10[__value * 2], 2, __first);
+ }
  
- declare i32 @__cxa_atexit(ptr, ptr, ptr)
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append3(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append3(char* __first, uint32_t __value) noexcept {
+   return __itoa::__append2(__itoa::__append1(__first, __value / 100), __value % 100);
+ }
  
--declare ptr @wobble(ptr returned, ptr ) 
-+declare ptr @wobble(ptr returned, ptr )
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append4(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append4(char* __first, uint32_t __value) noexcept {
+   return __itoa::__append2(__itoa::__append2(__first, __value / 100), __value % 100);
+ }
  
- declare i32 @quux(...)
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append5(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append5(char* __first, uint32_t __value) noexcept {
+   return __itoa::__append4(__itoa::__append1(__first, __value / 10000), __value % 10000);
+ }
  
-@@ -236,6 +236,20 @@
-   resume { ptr, i32 } undef
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append6(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append6(char* __first, uint32_t __value) noexcept {
+   return __itoa::__append4(__itoa::__append2(__first, __value / 10000), __value % 10000);
  }
  
-+; CHECK-LABEL: func_reduced_remat_regclass_error:
-+define void @func_reduced_remat_regclass_error(ptr %global.10, ptr %global.15) {
-+bb14:
-+  store i32 999, ptr %global.10, align 4
-+  call void @llvm.memset.p0.i32(ptr null, i8 0, i32 12, i1 false)
-+  call void @llvm.memcpy.p0.p0.i32(ptr null, ptr null, i32 60, i1 false)
-+  %tmp34 = call ptr @_Znwm()
-+  store i32 999, ptr %global.15, align 4
-+  call void @llvm.memcpy.p0.p0.i32(ptr %global.10, ptr null, i32 52, i1 false)
-+  call void @llvm.memset.p0.i32(ptr null, i8 0, i32 12, i1 false)
-+  call void @llvm.memset.p0.i32(ptr null, i8 0, i32 12, i1 false)
-+  ret void
-+}
-+
- declare void @llvm.trap()
- 
- declare void @llvm.memcpy.p0.p0.i32(ptr , ptr , i32, i1)
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/ARM/splitkit-remat-regclass-constraint-regression.ll b/llvm/test/CodeGen/ARM/splitkit-remat-regclass-constraint-regression.ll
---- a/llvm/test/CodeGen/ARM/splitkit-remat-regclass-constraint-regression.ll
-+++ b/llvm/test/CodeGen/ARM/splitkit-remat-regclass-constraint-regression.ll
-@@ -0,0 +1,39 @@
-+; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py UTC_ARGS: --version 5
-+; RUN: llc -verify-machineinstrs -stress-regalloc=2 -o - %s | FileCheck %s
-+
-+; Check that no register class constraint error is produced during
-+; rematerialization
-+
-+target triple = "thumbv7-apple-ios"
-+
-+declare ptr @_Znwm()
-+
-+define void @func() {
-+; CHECK-LABEL: func:
-+; CHECK:       @ %bb.0: @ %bb14
-+; CHECK-NEXT:    str lr, [sp, #-4]!
-+; CHECK-NEXT:    movs r0, #0
-+; CHECK-NEXT:    movs r1, #4
-+; CHECK-NEXT:    str r0, [r1]
-+; CHECK-NEXT:    movs r1, #8
-+; CHECK-NEXT:    str r0, [r1]
-+; CHECK-NEXT:    str r0, [r0]
-+; CHECK-NEXT:    bl __Znwm
-+; CHECK-NEXT:    movs r1, #0
-+; CHECK-NEXT:    movs r0, #4
-+; CHECK-NEXT:    str r1, [r0]
-+; CHECK-NEXT:    movs r0, #8
-+; CHECK-NEXT:    str r1, [r0]
-+; CHECK-NEXT:    str r1, [r1]
-+; CHECK-NEXT:    ldr lr, [sp], #4
-+; CHECK-NEXT:    bx lr
-+bb14:
-+  call void @llvm.memset.p0.i32(ptr null, i8 0, i32 12, i1 false)
-+  %tmp34 = call ptr @_Znwm()
-+  call void @llvm.memset.p0.i32(ptr null, i8 0, i32 12, i1 false)
-+  ret void
-+}
-+
-+declare void @llvm.memset.p0.i32(ptr writeonly captures(none), i8, i32, i1 immarg) #0
-+
-+attributes #0 = { nocallback nofree nounwind willreturn memory(argmem: write) }
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/fptosi-sat-vector-128.ll b/llvm/test/CodeGen/X86/fptosi-sat-vector-128.ll
---- a/llvm/test/CodeGen/X86/fptosi-sat-vector-128.ll
-+++ b/llvm/test/CodeGen/X86/fptosi-sat-vector-128.ll
-@@ -241,21 +241,21 @@
- ; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
- ; CHECK-NEXT:    callq __fixsfti@PLT
- ; CHECK-NEXT:    movq %rdx, %r15
--; CHECK-NEXT:    xorl %edx, %edx
-+; CHECK-NEXT:    xorl %r14d, %r14d
- ; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovbq %rdx, %rax
--; CHECK-NEXT:    movabsq $-9223372036854775808, %r14 # imm = 0x8000000000000000
--; CHECK-NEXT:    cmovbq %r14, %r15
-+; CHECK-NEXT:    cmovbq %r14, %rax
-+; CHECK-NEXT:    movabsq $-9223372036854775808, %rcx # imm = 0x8000000000000000
-+; CHECK-NEXT:    cmovbq %rcx, %r15
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    movabsq $9223372036854775807, %rbp # imm = 0x7FFFFFFFFFFFFFFF
- ; CHECK-NEXT:    cmovaq %rbp, %r15
- ; CHECK-NEXT:    movq $-1, %rcx
- ; CHECK-NEXT:    cmovaq %rcx, %rax
- ; CHECK-NEXT:    ucomiss %xmm0, %xmm0
--; CHECK-NEXT:    cmovpq %rdx, %rax
-+; CHECK-NEXT:    cmovpq %r14, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
--; CHECK-NEXT:    cmovpq %rdx, %r15
-+; CHECK-NEXT:    cmovpq %r14, %r15
- ; CHECK-NEXT:    movaps (%rsp), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    movhlps {{.*#+}} xmm0 = xmm0[1,1]
- ; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
-@@ -264,16 +264,16 @@
- ; CHECK-NEXT:    movq %rdx, %r13
- ; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    movl $0, %eax
--; CHECK-NEXT:    cmovbq %rax, %r12
--; CHECK-NEXT:    cmovbq %r14, %r13
-+; CHECK-NEXT:    cmovbq %r14, %r12
-+; CHECK-NEXT:    movabsq $-9223372036854775808, %rax # imm = 0x8000000000000000
-+; CHECK-NEXT:    cmovbq %rax, %r13
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovaq %rbp, %r13
--; CHECK-NEXT:    movq $-1, %rcx
--; CHECK-NEXT:    cmovaq %rcx, %r12
-+; CHECK-NEXT:    movq $-1, %rax
-+; CHECK-NEXT:    cmovaq %rax, %r12
- ; CHECK-NEXT:    ucomiss %xmm0, %xmm0
--; CHECK-NEXT:    cmovpq %rax, %r12
--; CHECK-NEXT:    cmovpq %rax, %r13
-+; CHECK-NEXT:    cmovpq %r14, %r12
-+; CHECK-NEXT:    cmovpq %r14, %r13
- ; CHECK-NEXT:    movaps (%rsp), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    shufps {{.*#+}} xmm0 = xmm0[3,3,3,3]
- ; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
-@@ -1187,14 +1187,14 @@
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovbq %r12, %rax
--; CHECK-NEXT:    movabsq $-9223372036854775808, %r13 # imm = 0x8000000000000000
--; CHECK-NEXT:    cmovbq %r13, %rdx
-+; CHECK-NEXT:    movabsq $-9223372036854775808, %rbp # imm = 0x8000000000000000
-+; CHECK-NEXT:    cmovbq %rbp, %rdx
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    movabsq $9223372036854775807, %r15 # imm = 0x7FFFFFFFFFFFFFFF
- ; CHECK-NEXT:    cmovaq %r15, %rdx
- ; CHECK-NEXT:    movq $-1, %rcx
- ; CHECK-NEXT:    cmovaq %rcx, %rax
--; CHECK-NEXT:    movq $-1, %rbp
-+; CHECK-NEXT:    movq $-1, %r13
- ; CHECK-NEXT:    ucomiss %xmm0, %xmm0
- ; CHECK-NEXT:    cmovpq %r12, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
-@@ -1209,10 +1209,10 @@
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovbq %r12, %rax
--; CHECK-NEXT:    cmovbq %r13, %rdx
-+; CHECK-NEXT:    cmovbq %rbp, %rdx
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovaq %r15, %rdx
--; CHECK-NEXT:    cmovaq %rbp, %rax
-+; CHECK-NEXT:    cmovaq %r13, %rax
- ; CHECK-NEXT:    movq $-1, %r14
- ; CHECK-NEXT:    ucomiss %xmm0, %xmm0
- ; CHECK-NEXT:    cmovpq %r12, %rax
-@@ -1228,7 +1228,7 @@
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovbq %r12, %rax
--; CHECK-NEXT:    cmovbq %r13, %rdx
-+; CHECK-NEXT:    cmovbq %rbp, %rdx
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovaq %r15, %rdx
- ; CHECK-NEXT:    cmovaq %r14, %rax
-@@ -1247,7 +1247,8 @@
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovbq %r12, %rax
--; CHECK-NEXT:    cmovbq %r13, %rdx
-+; CHECK-NEXT:    cmovbq %rbp, %rdx
-+; CHECK-NEXT:    movq %rbp, %r13
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovaq %r15, %rdx
- ; CHECK-NEXT:    cmovaq %r14, %rax
-@@ -1286,17 +1287,16 @@
- ; CHECK-NEXT:    movss {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 4-byte Reload
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    movl $0, %eax
--; CHECK-NEXT:    cmovbq %rax, %r14
--; CHECK-NEXT:    movabsq $-9223372036854775808, %rcx # imm = 0x8000000000000000
--; CHECK-NEXT:    cmovbq %rcx, %r15
-+; CHECK-NEXT:    cmovbq %r12, %r14
-+; CHECK-NEXT:    movabsq $-9223372036854775808, %rax # imm = 0x8000000000000000
-+; CHECK-NEXT:    cmovbq %rax, %r15
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
- ; CHECK-NEXT:    cmovaq %r13, %r15
--; CHECK-NEXT:    movq $-1, %rcx
--; CHECK-NEXT:    cmovaq %rcx, %r14
-+; CHECK-NEXT:    movq $-1, %rax
-+; CHECK-NEXT:    cmovaq %rax, %r14
- ; CHECK-NEXT:    ucomiss %xmm0, %xmm0
--; CHECK-NEXT:    cmovpq %rax, %r14
--; CHECK-NEXT:    cmovpq %rax, %r15
-+; CHECK-NEXT:    cmovpq %r12, %r14
-+; CHECK-NEXT:    cmovpq %r12, %r15
- ; CHECK-NEXT:    movdqa {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    psrldq {{.*#+}} xmm0 = xmm0[14,15],zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
- ; CHECK-NEXT:    callq __extendhfsf2@PLT
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/fptoui-sat-vector-128.ll b/llvm/test/CodeGen/X86/fptoui-sat-vector-128.ll
---- a/llvm/test/CodeGen/X86/fptoui-sat-vector-128.ll
-+++ b/llvm/test/CodeGen/X86/fptoui-sat-vector-128.ll
-@@ -263,17 +263,17 @@
- ; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
- ; CHECK-NEXT:    callq __fixunssfti@PLT
- ; CHECK-NEXT:    movq %rdx, %r15
--; CHECK-NEXT:    xorl %ebp, %ebp
-+; CHECK-NEXT:    xorl %r14d, %r14d
- ; CHECK-NEXT:    xorps %xmm0, %xmm0
- ; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm1 # 16-byte Reload
- ; CHECK-NEXT:    ucomiss %xmm0, %xmm1
--; CHECK-NEXT:    cmovbq %rbp, %r15
--; CHECK-NEXT:    cmovbq %rbp, %rax
-+; CHECK-NEXT:    cmovbq %r14, %r15
-+; CHECK-NEXT:    cmovbq %r14, %rax
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1
--; CHECK-NEXT:    movq $-1, %r14
--; CHECK-NEXT:    cmovaq %r14, %rax
-+; CHECK-NEXT:    movq $-1, %rbp
-+; CHECK-NEXT:    cmovaq %rbp, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
--; CHECK-NEXT:    cmovaq %r14, %r15
-+; CHECK-NEXT:    cmovaq %rbp, %r15
- ; CHECK-NEXT:    movaps (%rsp), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    movhlps {{.*#+}} xmm0 = xmm0[1,1]
- ; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
-@@ -282,11 +282,11 @@
- ; CHECK-NEXT:    movq %rdx, %r13
- ; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovbq %rbp, %r13
--; CHECK-NEXT:    cmovbq %rbp, %r12
-+; CHECK-NEXT:    cmovbq %r14, %r13
-+; CHECK-NEXT:    cmovbq %r14, %r12
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovaq %r14, %r12
--; CHECK-NEXT:    cmovaq %r14, %r13
-+; CHECK-NEXT:    cmovaq %rbp, %r12
-+; CHECK-NEXT:    cmovaq %rbp, %r13
- ; CHECK-NEXT:    movaps (%rsp), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    shufps {{.*#+}} xmm0 = xmm0[3,3,3,3]
- ; CHECK-NEXT:    movaps %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 16-byte Spill
-@@ -1149,18 +1149,18 @@
- ; CHECK-NEXT:    callq __extendhfsf2@PLT
- ; CHECK-NEXT:    movd %xmm0, {{[-0-9]+}}(%r{{[sb]}}p) # 4-byte Folded Spill
- ; CHECK-NEXT:    callq __fixunssfti@PLT
--; CHECK-NEXT:    xorl %r13d, %r13d
-+; CHECK-NEXT:    xorl %r12d, %r12d
- ; CHECK-NEXT:    pxor %xmm0, %xmm0
- ; CHECK-NEXT:    movss {{[-0-9]+}}(%r{{[sb]}}p), %xmm1 # 4-byte Reload
- ; CHECK-NEXT:    # xmm1 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss %xmm0, %xmm1
--; CHECK-NEXT:    cmovbq %r13, %rdx
--; CHECK-NEXT:    cmovbq %r13, %rax
-+; CHECK-NEXT:    cmovbq %r12, %rdx
-+; CHECK-NEXT:    cmovbq %r12, %rax
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm1
--; CHECK-NEXT:    movq $-1, %r12
--; CHECK-NEXT:    cmovaq %r12, %rax
-+; CHECK-NEXT:    movq $-1, %r13
-+; CHECK-NEXT:    cmovaq %r13, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
--; CHECK-NEXT:    cmovaq %r12, %rdx
-+; CHECK-NEXT:    cmovaq %r13, %rdx
- ; CHECK-NEXT:    movq %rdx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
- ; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    shufps {{.*#+}} xmm0 = xmm0[1,1,1,1]
-@@ -1170,12 +1170,12 @@
- ; CHECK-NEXT:    movss {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 4-byte Reload
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovbq %r13, %rdx
--; CHECK-NEXT:    cmovbq %r13, %rax
-+; CHECK-NEXT:    cmovbq %r12, %rdx
-+; CHECK-NEXT:    cmovbq %r12, %rax
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovaq %r12, %rax
-+; CHECK-NEXT:    cmovaq %r13, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
--; CHECK-NEXT:    cmovaq %r12, %rdx
-+; CHECK-NEXT:    cmovaq %r13, %rdx
- ; CHECK-NEXT:    movq %rdx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
- ; CHECK-NEXT:    movdqa {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    psrlq $48, %xmm0
-@@ -1185,12 +1185,12 @@
- ; CHECK-NEXT:    movss {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 4-byte Reload
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovbq %r13, %rdx
--; CHECK-NEXT:    cmovbq %r13, %rax
-+; CHECK-NEXT:    cmovbq %r12, %rdx
-+; CHECK-NEXT:    cmovbq %r12, %rax
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovaq %r12, %rax
-+; CHECK-NEXT:    cmovaq %r13, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
--; CHECK-NEXT:    cmovaq %r12, %rdx
-+; CHECK-NEXT:    cmovaq %r13, %rdx
- ; CHECK-NEXT:    movq %rdx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
- ; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    movhlps {{.*#+}} xmm0 = xmm0[1,1]
-@@ -1200,12 +1200,12 @@
- ; CHECK-NEXT:    movss {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 4-byte Reload
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovbq %r13, %rdx
--; CHECK-NEXT:    cmovbq %r13, %rax
-+; CHECK-NEXT:    cmovbq %r12, %rdx
-+; CHECK-NEXT:    cmovbq %r12, %rax
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovaq %r12, %rax
-+; CHECK-NEXT:    cmovaq %r13, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
--; CHECK-NEXT:    cmovaq %r12, %rdx
-+; CHECK-NEXT:    cmovaq %r13, %rdx
- ; CHECK-NEXT:    movq %rdx, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
- ; CHECK-NEXT:    movdqa {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    psrldq {{.*#+}} xmm0 = xmm0[10,11,12,13,14,15],zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
-@@ -1216,12 +1216,12 @@
- ; CHECK-NEXT:    movss {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 4-byte Reload
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovbq %r13, %rbp
--; CHECK-NEXT:    cmovbq %r13, %rax
-+; CHECK-NEXT:    cmovbq %r12, %rbp
-+; CHECK-NEXT:    cmovbq %r12, %rax
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovaq %r12, %rax
-+; CHECK-NEXT:    cmovaq %r13, %rax
- ; CHECK-NEXT:    movq %rax, {{[-0-9]+}}(%r{{[sb]}}p) # 8-byte Spill
--; CHECK-NEXT:    cmovaq %r12, %rbp
-+; CHECK-NEXT:    cmovaq %r13, %rbp
- ; CHECK-NEXT:    movaps {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    shufps {{.*#+}} xmm0 = xmm0[3,3,3,3]
- ; CHECK-NEXT:    callq __extendhfsf2@PLT
-@@ -1232,11 +1232,11 @@
- ; CHECK-NEXT:    movss {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 4-byte Reload
- ; CHECK-NEXT:    # xmm0 = mem[0],zero,zero,zero
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovbq %r13, %r15
--; CHECK-NEXT:    cmovbq %r13, %r14
-+; CHECK-NEXT:    cmovbq %r12, %r15
-+; CHECK-NEXT:    cmovbq %r12, %r14
- ; CHECK-NEXT:    ucomiss {{\.?LCPI[0-9]+_[0-9]+}}(%rip), %xmm0
--; CHECK-NEXT:    cmovaq %r12, %r14
--; CHECK-NEXT:    cmovaq %r12, %r15
-+; CHECK-NEXT:    cmovaq %r13, %r14
-+; CHECK-NEXT:    cmovaq %r13, %r15
- ; CHECK-NEXT:    movdqa {{[-0-9]+}}(%r{{[sb]}}p), %xmm0 # 16-byte Reload
- ; CHECK-NEXT:    psrldq {{.*#+}} xmm0 = xmm0[14,15],zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero,zero
- ; CHECK-NEXT:    callq __extendhfsf2@PLT
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/splitkit-remat-broken-subreg-constraint.mir b/llvm/test/CodeGen/X86/splitkit-remat-broken-subreg-constraint.mir
---- a/llvm/test/CodeGen/X86/splitkit-remat-broken-subreg-constraint.mir
-+++ b/llvm/test/CodeGen/X86/splitkit-remat-broken-subreg-constraint.mir
-@@ -0,0 +1,45 @@
-+# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py UTC_ARGS: --version 5
-+# RUN: llc -mtriple=x86_64-- -run-pass=greedy -verify-regalloc -stress-regalloc=2 -o - %s | FileCheck %s
-+
-+# Test verifier error which happened after 8476a5d480304 during
-+# rematerialization.
-+
-+---
-+name:            remat_regclass_verifier_error
-+tracksRegLiveness: true
-+body:             |
-+  bb.0:
-+    liveins: $rax, $rbx, $rcx, $rdi
-+
-+    ; CHECK-LABEL: name: remat_regclass_verifier_error
-+    ; CHECK: liveins: $rax, $rbx, $rcx, $rdi
-+    ; CHECK-NEXT: {{  $}}
-+    ; CHECK-NEXT: dead [[COPY:%[0-9]+]]:gr64 = COPY $rax
-+    ; CHECK-NEXT: dead [[COPY1:%[0-9]+]]:gr64 = COPY $rbx
-+    ; CHECK-NEXT: [[COPY2:%[0-9]+]]:gr64 = COPY $rcx
-+    ; CHECK-NEXT: MOV64mr %stack.0, 1, $noreg, 0, $noreg, [[COPY2]] :: (store (s64) into %stack.0)
-+    ; CHECK-NEXT: [[COPY3:%[0-9]+]]:gr64 = COPY $rdi
-+    ; CHECK-NEXT: undef [[MOV32r0_:%[0-9]+]].sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
-+    ; CHECK-NEXT: dead [[COPY3:%[0-9]+]]:gr64 = CMOV64rr [[COPY3]], [[MOV32r0_]], 10, implicit undef $eflags
-+    ; CHECK-NEXT: undef [[MOV32r0_1:%[0-9]+]].sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
-+    ; CHECK-NEXT: [[MOV64rm:%[0-9]+]]:gr64 = MOV64rm %stack.0, 1, $noreg, 0, $noreg :: (load (s64) from %stack.0)
-+    ; CHECK-NEXT: [[MOV64rm:%[0-9]+]]:gr64 = CMOV64rr [[MOV64rm]], [[MOV32r0_1]], 10, implicit undef $eflags
-+    ; CHECK-NEXT: dead [[COPY4:%[0-9]+]]:gr64 = COPY $rdi
-+    ; CHECK-NEXT: undef [[MOV32r0_2:%[0-9]+]].sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
-+    ; CHECK-NEXT: [[CMOV64rr:%[0-9]+]]:gr64 = CMOV64rr [[MOV64rm]], [[MOV32r0_2]], 10, implicit undef $eflags
-+    ; CHECK-NEXT: $rax = COPY [[CMOV64rr]]
-+    ; CHECK-NEXT: RET 0, $rax
-+    %0:gr64 = COPY $rax
-+    %1:gr64 = COPY $rbx
-+    undef %2.sub_32bit:gr64_with_sub_8bit = MOV32r0 implicit-def dead $eflags
-+    %0:gr64 = COPY $rcx
-+    %1:gr64 = COPY %0
-+    %0:gr64 = COPY $rdi
-+    %0:gr64 = CMOV64rr %0, %2, 10, implicit undef $eflags
-+    %1:gr64 = CMOV64rr %1, %2, 10, implicit undef $eflags
-+    %3:gr64 = COPY $rdi
-+    %3:gr64 = CMOV64rr %1, %2, 10, implicit undef $eflags
-+    $rax = COPY %3
-+    RET 0, killed $rax
-+...
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append7(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append7(char* __first, uint32_t __value) noexcept {
+   return __itoa::__append6(__itoa::__append1(__first, __value / 1000000), __value % 1000000);
+ }
+ 
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append8(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append8(char* __first, uint32_t __value) noexcept {
+   return __itoa::__append6(__itoa::__append2(__first, __value / 1000000), __value % 1000000);
+ }
+ 
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append9(char* __first, uint32_t __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char* __append9(char* __first, uint32_t __value) noexcept {
+   return __itoa::__append8(__itoa::__append1(__first, __value / 100000000), __value % 100000000);
+ }
+ 
+ template <class _Tp>
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI char* __append10(char* __first, _Tp __value) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI char* __append10(char* __first, _Tp __value) noexcept {
+   return __itoa::__append8(__itoa::__append2(__first, static_cast<uint32_t>(__value / 100000000)),
+                            static_cast<uint32_t>(__value % 100000000));
+ }
+ 
+ _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char*
+-__base_10_u32(char* __first, uint32_t __value) _NOEXCEPT {
++__base_10_u32(char* __first, uint32_t __value) noexcept {
+   if (__value < 1000000) {
+     if (__value < 10000) {
+       if (__value < 100) {
+@@ -108,7 +110,7 @@
+ }
+ 
+ _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char*
+-__base_10_u64(char* __buffer, uint64_t __value) _NOEXCEPT {
++__base_10_u64(char* __buffer, uint64_t __value) noexcept {
+   if (__value <= UINT32_MAX)
+     return __itoa::__base_10_u32(__buffer, static_cast<uint32_t>(__value));
+ 
+@@ -130,13 +132,13 @@
+ /// \note The lookup table contains a partial set of exponents limiting the
+ /// range that can be used. However the range is sufficient for
+ /// \ref __base_10_u128.
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline __uint128_t __pow_10(int __exp) _NOEXCEPT {
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline __uint128_t __pow_10(int __exp) noexcept {
+   _LIBCPP_ASSERT_INTERNAL(__exp >= __pow10_128_offset, "Index out of bounds");
+   return __pow10_128[__exp - __pow10_128_offset];
+ }
+ 
+ _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI inline char*
+-__base_10_u128(char* __buffer, __uint128_t __value) _NOEXCEPT {
++__base_10_u128(char* __buffer, __uint128_t __value) noexcept {
+   _LIBCPP_ASSERT_INTERNAL(
+       __value > numeric_limits<uint64_t>::max(), "The optimizations for this algorithm fails when this isn't true.");
+ 
+@@ -177,6 +179,8 @@
+ #  endif
+ } // namespace __itoa
+ 
++#endif // _LIBCPP_STD_VER >= 17
 +
-diff -ruN --strip-trailing-cr a/llvm/test/CodeGen/X86/statepoint-invoke-ra-enter-at-end.mir b/llvm/test/CodeGen/X86/statepoint-invoke-ra-enter-at-end.mir
---- a/llvm/test/CodeGen/X86/statepoint-invoke-ra-enter-at-end.mir
-+++ b/llvm/test/CodeGen/X86/statepoint-invoke-ra-enter-at-end.mir
-@@ -343,9 +343,8 @@
-   ; CHECK-NEXT:   [[MOV64rm4:%[0-9]+]]:gr64 = NOT64r [[MOV64rm4]]
-   ; CHECK-NEXT:   CMP64rr [[MOV64rm4]], [[COPY7]], implicit-def $eflags
-   ; CHECK-NEXT:   undef [[MOV32ri1:%[0-9]+]].sub_32bit:gr64_with_sub_8bit = MOV32ri 0
--  ; CHECK-NEXT:   [[COPY8:%[0-9]+]]:gr64 = COPY [[MOV32ri1]]
--  ; CHECK-NEXT:   [[MOV64rm4:%[0-9]+]]:gr64 = CMOV64rr [[MOV64rm4]], [[COPY8]], 4, implicit killed $eflags
--  ; CHECK-NEXT:   INLINEASM &"lock btsq $0,($1)", 1 /* sideeffect attdialect */, 4784137 /* reguse:GR64 */, [[COPY8]], 4784137 /* reguse:GR64 */, undef %56:gr64, 12 /* clobber */, implicit-def dead early-clobber $df, 12 /* clobber */, implicit-def early-clobber $fpsw, 12 /* clobber */, implicit-def dead early-clobber $eflags
-+  ; CHECK-NEXT:   [[MOV64rm4:%[0-9]+]]:gr64 = CMOV64rr [[MOV64rm4]], [[MOV32ri1]], 4, implicit killed $eflags
-+  ; CHECK-NEXT:   INLINEASM &"lock btsq $0,($1)", 1 /* sideeffect attdialect */, 4784137 /* reguse:GR64 */, [[MOV32ri1]], 4784137 /* reguse:GR64 */, undef %56:gr64, 12 /* clobber */, implicit-def dead early-clobber $df, 12 /* clobber */, implicit-def early-clobber $fpsw, 12 /* clobber */, implicit-def dead early-clobber $eflags
-   ; CHECK-NEXT:   LCMPXCHG32 undef %67:gr64, 1, $noreg, 0, $noreg, [[COPY6]], implicit-def dead $eax, implicit-def dead $eflags, implicit undef $eax :: (load store acquire monotonic (s32) on `ptr addrspace(1) undef`, addrspace 1)
-   ; CHECK-NEXT:   ADJCALLSTACKDOWN64 0, 0, 0, implicit-def dead $rsp, implicit-def dead $eflags, implicit-def dead $ssp, implicit $rsp, implicit $ssp
-   ; CHECK-NEXT:   $rdi = COPY [[COPY5]]
-diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/buildvectors-parent-phi-nodes.ll b/llvm/test/Transforms/SLPVectorizer/X86/buildvectors-parent-phi-nodes.ll
---- a/llvm/test/Transforms/SLPVectorizer/X86/buildvectors-parent-phi-nodes.ll
-+++ b/llvm/test/Transforms/SLPVectorizer/X86/buildvectors-parent-phi-nodes.ll
-@@ -0,0 +1,54 @@
-+; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
-+; RUN: opt -S --passes=slp-vectorizer -mtriple=x86_64-generic-linux-gnu -mattr=+avx < %s | FileCheck %s
+ _LIBCPP_END_NAMESPACE_STD
+ 
+ _LIBCPP_POP_MACROS
+diff -ruN --strip-trailing-cr a/libcxx/include/__charconv/to_chars_integral.h b/libcxx/include/__charconv/to_chars_integral.h
+--- a/libcxx/include/__charconv/to_chars_integral.h
++++ b/libcxx/include/__charconv/to_chars_integral.h
+@@ -39,12 +39,16 @@
+ 
+ _LIBCPP_BEGIN_NAMESPACE_STD
+ 
++#if _LIBCPP_STD_VER >= 17
 +
-+define void @test(ptr %0, float %1) {
-+; CHECK-LABEL: define void @test(
-+; CHECK-SAME: ptr [[TMP0:%.*]], float [[TMP1:%.*]]) #[[ATTR0:[0-9]+]] {
-+; CHECK-NEXT:    [[TMP3:%.*]] = load float, ptr [[TMP0]], align 4
-+; CHECK-NEXT:    [[TMP4:%.*]] = insertelement <2 x float> <float 0.000000e+00, float poison>, float [[TMP3]], i32 1
-+; CHECK-NEXT:    [[TMP5:%.*]] = insertelement <4 x float> <float poison, float 0.000000e+00, float 0.000000e+00, float 0.000000e+00>, float [[TMP3]], i32 0
-+; CHECK-NEXT:    [[TMP6:%.*]] = insertelement <2 x float> poison, float [[TMP1]], i32 0
-+; CHECK-NEXT:    [[TMP7:%.*]] = shufflevector <2 x float> [[TMP6]], <2 x float> poison, <2 x i32> zeroinitializer
-+; CHECK-NEXT:    br label %[[BB8:.*]]
-+; CHECK:       [[BB8]]:
-+; CHECK-NEXT:    [[TMP9:%.*]] = phi <4 x float> [ [[TMP15:%.*]], %[[BB8]] ], [ [[TMP5]], [[TMP2:%.*]] ]
-+; CHECK-NEXT:    [[TMP10:%.*]] = phi <2 x float> [ [[TMP7]], %[[BB8]] ], [ [[TMP4]], [[TMP2]] ]
-+; CHECK-NEXT:    [[TMP11:%.*]] = shufflevector <2 x float> [[TMP10]], <2 x float> poison, <4 x i32> <i32 0, i32 1, i32 0, i32 0>
-+; CHECK-NEXT:    [[TMP12:%.*]] = fmul <4 x float> [[TMP9]], zeroinitializer
-+; CHECK-NEXT:    [[TMP13:%.*]] = fadd <4 x float> [[TMP12]], zeroinitializer
-+; CHECK-NEXT:    store <4 x float> [[TMP13]], ptr [[TMP0]], align 16
-+; CHECK-NEXT:    [[TMP14:%.*]] = fmul <4 x float> [[TMP11]], zeroinitializer
-+; CHECK-NEXT:    [[TMP15]] = fadd <4 x float> [[TMP14]], zeroinitializer
-+; CHECK-NEXT:    br label %[[BB8]]
-+;
-+  %3 = load float, ptr %0, align 4
-+  br label %4
++to_chars_result to_chars(char*, char*, bool, int = 10) = delete;
 +
-+4:
-+  %5 = phi float [ %1, %4 ], [ %3, %2 ]
-+  %6 = phi float [ %1, %4 ], [ 0.000000e+00, %2 ]
-+  %7 = phi float [ %28, %4 ], [ 0.000000e+00, %2 ]
-+  %8 = phi float [ %26, %4 ], [ 0.000000e+00, %2 ]
-+  %9 = phi float [ %26, %4 ], [ %3, %2 ]
-+  %10 = phi float [ %24, %4 ], [ 0.000000e+00, %2 ]
-+  %11 = fmul float %9, 0.000000e+00
-+  %12 = fadd float %11, 0.000000e+00
-+  %13 = fmul float %7, 0.000000e+00
-+  %14 = fadd float %13, 0.000000e+00
-+  %15 = fmul float %10, 0.000000e+00
-+  %16 = fadd float %15, 0.000000e+00
-+  %17 = fmul float %8, 0.000000e+00
-+  %18 = fadd float %17, 0.000000e+00
-+  %19 = insertelement <4 x float> zeroinitializer, float %12, i64 0
-+  %20 = insertelement <4 x float> %19, float %14, i64 1
-+  %21 = insertelement <4 x float> %20, float %16, i64 2
-+  %22 = insertelement <4 x float> %21, float %18, i64 3
-+  store <4 x float> %22, ptr %0, align 16
-+  %23 = fmul float %6, 0.000000e+00
-+  %24 = fadd float %23, 0.000000e+00
-+  %25 = fmul float %6, 0.000000e+00
-+  %26 = fadd float %25, 0.000000e+00
-+  %27 = fmul float %5, 0.000000e+00
-+  %28 = fadd float %27, 0.000000e+00
-+  br label %4
-+}
-diff -ruN --strip-trailing-cr a/mlir/docs/DeclarativeRewrites.md b/mlir/docs/DeclarativeRewrites.md
---- a/mlir/docs/DeclarativeRewrites.md
-+++ b/mlir/docs/DeclarativeRewrites.md
-@@ -237,9 +237,9 @@
- 
- Given that `COp` was specified with table-driven op definition, there will be
- several `build()` methods generated for it. One of them has aggregated
--parameters for result types, operands, and properties in the signature: `void
-+parameters for result types, operands, and attributes in the signature: `void
- COp::build(..., ArrayRef<Type> resultTypes, Array<Value> operands,
--const COp::Properties& properties)`. The pattern in the above calls this `build()`
-+ArrayRef<NamedAttribute> attr)`. The pattern in the above calls this `build()`
- method for constructing the `COp`.
- 
- In general, arguments in the result pattern will be passed directly to the
-diff -ruN --strip-trailing-cr a/mlir/docs/DefiningDialects/Operations.md b/mlir/docs/DefiningDialects/Operations.md
---- a/mlir/docs/DefiningDialects/Operations.md
-+++ b/mlir/docs/DefiningDialects/Operations.md
-@@ -465,18 +465,7 @@
- The following builders are generated:
- 
- ```c++
--// All result-types/operands/properties/discardable attributes have one
--// aggregate parameter. `Properties` is the properties structure of
--// `MyOp`.
--static void build(OpBuilder &odsBuilder, OperationState &odsState,
--                  TypeRange resultTypes,
--                  ValueRange operands,
--                  Properties properties,
--                  ArrayRef<NamedAttribute> discardableAttributes = {});
--
- // All result-types/operands/attributes have one aggregate parameter.
--// Inherent properties and discardable attributes are mixed together in the
--//  `attributes` dictionary.
- static void build(OpBuilder &odsBuilder, OperationState &odsState,
-                   TypeRange resultTypes,
-                   ValueRange operands,
-@@ -510,27 +499,19 @@
- // All operands/attributes have aggregate parameters.
- // Generated if return type can be inferred.
- static void build(OpBuilder &odsBuilder, OperationState &odsState,
--                  ValueRange operands,
--                  Properties properties,
--                  ArrayRef<NamedAttribute> discardableAttributes);
--
--// All operands/attributes have aggregate parameters.
--// Generated if return type can be inferred. Uses the legacy merged attribute
--// dictionary.
--static void build(OpBuilder &odsBuilder, OperationState &odsState,
-                   ValueRange operands, ArrayRef<NamedAttribute> attributes);
- 
- // (And manually specified builders depending on the specific op.)
- ```
- 
--The first two forms provide basic uniformity so that we can create ops using
--the same form regardless of the exact op. This is particularly useful for
-+The first form provides basic uniformity so that we can create ops using the
-+same form regardless of the exact op. This is particularly useful for
- implementing declarative pattern rewrites.
- 
--The third and fourth forms are good for use in manually written code, given that
-+The second and third forms are good for use in manually written code, given that
- they provide better guarantee via signatures.
- 
--The fourth form will be generated if any of the op's attribute has different
-+The third form will be generated if any of the op's attribute has different
- `Attr.returnType` from `Attr.storageType` and we know how to build an attribute
- from an unwrapped value (i.e., `Attr.constBuilderCall` is defined.)
- Additionally, for the third form, if an attribute appearing later in the
-diff -ruN --strip-trailing-cr a/mlir/include/mlir/IR/OpDefinition.h b/mlir/include/mlir/IR/OpDefinition.h
---- a/mlir/include/mlir/IR/OpDefinition.h
-+++ b/mlir/include/mlir/IR/OpDefinition.h
-@@ -74,10 +74,7 @@
- 
- /// Structure used by default as a "marker" when no "Properties" are set on an
- /// Operation.
--struct EmptyProperties {
--  bool operator==(const EmptyProperties &) const { return true; }
--  bool operator!=(const EmptyProperties &) const { return false; }
--};
-+struct EmptyProperties {};
- 
- /// Traits to detect whether an Operation defined a `Properties` type, otherwise
- /// it'll default to `EmptyProperties`.
-diff -ruN --strip-trailing-cr a/mlir/include/mlir/IR/OperationSupport.h b/mlir/include/mlir/IR/OperationSupport.h
---- a/mlir/include/mlir/IR/OperationSupport.h
-+++ b/mlir/include/mlir/IR/OperationSupport.h
-@@ -1029,24 +1029,6 @@
-   setProperties(Operation *op,
-                 function_ref<InFlightDiagnostic()> emitError) const;
- 
--  // Make `newProperties` the source of the properties that will be copied into
--  // the operation. The memory referenced by `newProperties` must remain live
--  // until after the `Operation` is created, at which time it may be
--  // deallocated. Calls to `getOrAddProperties<>() will return references to
--  // this memory.
--  template <typename T>
--  void useProperties(T &newProperties) {
--    assert(!properties &&
--           "Can't provide a properties struct when one has been allocated");
--    properties = &newProperties;
--    propertiesDeleter = [](OpaqueProperties) {};
--    propertiesSetter = [](OpaqueProperties newProp,
--                          const OpaqueProperties prop) {
--      *newProp.as<T *>() = *prop.as<const T *>();
--    };
--    propertiesId = TypeID::get<T>();
--  }
--
-   void addOperands(ValueRange newOperands);
- 
-   void addTypes(ArrayRef<Type> newTypes) {
-diff -ruN --strip-trailing-cr a/mlir/test/lib/Dialect/Test/TestOps.td b/mlir/test/lib/Dialect/Test/TestOps.td
---- a/mlir/test/lib/Dialect/Test/TestOps.td
-+++ b/mlir/test/lib/Dialect/Test/TestOps.td
-@@ -2504,13 +2504,6 @@
-   let results = (outs F32:$result);
+ template <typename _Tp>
+-inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
++inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
+ __to_chars_itoa(char* __first, char* __last, _Tp __value, false_type);
+ 
+ template <typename _Tp>
+-inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
++inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
+ __to_chars_itoa(char* __first, char* __last, _Tp __value, true_type) {
+   auto __x = std::__to_unsigned_like(__value);
+   if (__value < 0 && __first != __last) {
+@@ -56,7 +60,7 @@
  }
  
--// An inherent attribute. Test collective builders, both those that take properties as
--// properties structs and those that take an attribute dictionary.
--def TableGenBuildOp7 : TEST_Op<"tblgen_build_7", []> {
--  let arguments = (ins BoolAttr:$attr0);
--  let results = (outs);
--}
--
- //===----------------------------------------------------------------------===//
- // Test BufferPlacement
- //===----------------------------------------------------------------------===//
-diff -ruN --strip-trailing-cr a/mlir/test/mlir-tblgen/op-attribute.td b/mlir/test/mlir-tblgen/op-attribute.td
---- a/mlir/test/mlir-tblgen/op-attribute.td
-+++ b/mlir/test/mlir-tblgen/op-attribute.td
-@@ -165,12 +165,6 @@
- // DEF:        ::llvm::ArrayRef<::mlir::NamedAttribute> attributes
- // DEF:      odsState.addAttributes(attributes);
- 
--// DEF:      void AOp::build(
--// DEF-SAME:   const Properties &properties,
--// DEF-SAME:   ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes
--// DEF:      odsState.useProperties(const_cast<Properties&>(properties));
--// DEF:      odsState.addAttributes(discardableAttributes);
--
- // DEF:      void AOp::populateDefaultProperties
- 
- // Test the above but with prefix.
-@@ -285,12 +279,6 @@
- // DEF:        ::llvm::ArrayRef<::mlir::NamedAttribute> attributes
- // DEF:      odsState.addAttributes(attributes);
- 
--// DEF:      void AgetOp::build(
--// DEF-SAME:   const Properties &properties
--// DEF-SAME:   ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes
--// DEF:      odsState.useProperties(const_cast<Properties&>(properties));
--// DEF:      odsState.addAttributes(discardableAttributes);
--
- // Test the above but using properties.
- def ApropOp : NS_Op<"a_prop_op", []> {
-   let arguments = (ins
-diff -ruN --strip-trailing-cr a/mlir/test/mlir-tblgen/op-decl-and-defs.td b/mlir/test/mlir-tblgen/op-decl-and-defs.td
---- a/mlir/test/mlir-tblgen/op-decl-and-defs.td
-+++ b/mlir/test/mlir-tblgen/op-decl-and-defs.td
-@@ -119,7 +119,6 @@
- // CHECK:   static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type r, ::mlir::TypeRange s, ::mlir::Value a, ::mlir::ValueRange b, uint32_t attr1, /*optional*/::mlir::FloatAttr some_attr2, unsigned someRegionsCount)
- // CHECK:   static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::ValueRange b, uint32_t attr1, /*optional*/::mlir::FloatAttr some_attr2, unsigned someRegionsCount);
- // CHECK:   static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes, unsigned numRegions)
--// CHECK:   static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes, unsigned numRegions)
- // CHECK:   static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
- // CHECK:   void print(::mlir::OpAsmPrinter &p);
- // CHECK:   ::llvm::LogicalResult verifyInvariants();
-@@ -232,7 +231,6 @@
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type b, ::mlir::Value a);
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a);
- // CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {})
--// CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes = {})
- 
- // Check suppression of "separate arg, separate result" build method for an op
- // with single variadic arg and single variadic result (since it will be
-@@ -283,8 +281,6 @@
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b);
- // CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
--// CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes = {});
--// CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes = {});
- 
- // Check default value of `attributes` for the `genInferredTypeCollectiveParamBuilder` builder
- def NS_JOp : NS_Op<"op_with_InferTypeOpInterface_interface", [DeclareOpInterfaceMethods<InferTypeOpInterface>]> {
-@@ -297,8 +293,6 @@
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b);
- // CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
--// CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes = {});
--// CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes = {});
- 
- // Test usage of TraitList getting flattened during emission.
- def NS_KOp : NS_Op<"k_op", [IsolatedFromAbove,
-@@ -335,8 +329,6 @@
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value a, ::mlir::Value b, uint32_t attr1);
- // CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
- // CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
--// CHECK: static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes = {});
--// CHECK: static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes = {});
- 
- def NS_MOp : NS_Op<"op_with_single_result_and_fold_adaptor_fold", []> {
-   let results = (outs AnyType:$res);
-diff -ruN --strip-trailing-cr a/mlir/test/mlir-tblgen/op-result.td b/mlir/test/mlir-tblgen/op-result.td
---- a/mlir/test/mlir-tblgen/op-result.td
-+++ b/mlir/test/mlir-tblgen/op-result.td
-@@ -57,9 +57,7 @@
- 
- // CHECK-LABEL: OpD definitions
- // CHECK: void OpD::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes)
--// CHECK: odsState.addTypes({::llvm::cast<::mlir::TypeAttr>(typeAttr).getValue()});
--// CHECK: void OpD::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes)
--// CHECK: odsState.addTypes({::llvm::cast<::mlir::TypeAttr>(typeAttr).getValue()});
-+// CHECK: odsState.addTypes({::llvm::cast<::mlir::TypeAttr>(attr.getValue()).getValue()});
- 
- def OpE : NS_Op<"value_attr_as_result_type", [FirstAttrDerivedResultType]> {
-   let arguments = (ins I32:$x, F32Attr:$attr);
-@@ -68,10 +66,7 @@
- 
- // CHECK-LABEL: OpE definitions
- // CHECK: void OpE::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes)
--// CHECK: odsState.addTypes({::llvm::cast<::mlir::TypedAttr>(typeAttr).getType()});
--// CHECK: void OpE::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes)
--// CHECK: ::mlir::Attribute typeAttr = properties.getAttr();
--// CHECK: odsState.addTypes({::llvm::cast<::mlir::TypedAttr>(typeAttr).getType()});
-+// CHECK: odsState.addTypes({::llvm::cast<::mlir::TypedAttr>(attr.getValue()).getType()});
- 
- def OpF : NS_Op<"one_variadic_result_op", []> {
-   let results = (outs Variadic<I32>:$x);
-@@ -123,8 +118,6 @@
- 
- // CHECK-LABEL: OpK::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes)
- // CHECK: odsState.addTypes({operands[0].getType()});
--// CHECK-LABEL: OpK::build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, const Properties &properties, ::llvm::ArrayRef<::mlir::NamedAttribute> discardableAttributes)
--// CHECK: odsState.addTypes({operands[0].getType()});
- 
- // Test with inferred shapes and interleaved with operands/attributes.
- //
-diff -ruN --strip-trailing-cr a/mlir/tools/mlir-tblgen/OpDefinitionsGen.cpp b/mlir/tools/mlir-tblgen/OpDefinitionsGen.cpp
---- a/mlir/tools/mlir-tblgen/OpDefinitionsGen.cpp
-+++ b/mlir/tools/mlir-tblgen/OpDefinitionsGen.cpp
-@@ -411,15 +411,6 @@
-       return true;
-     if (!op.getDialect().usePropertiesForAttributes())
-       return false;
--    return true;
--  }
--
--  /// Returns whether the operation will have a non-empty `Properties` struct.
--  bool hasNonEmptyPropertiesStruct() const {
--    if (!op.getProperties().empty())
--      return true;
--    if (!hasProperties())
--      return false;
-     if (op.getTrait("::mlir::OpTrait::AttrSizedOperandSegments") ||
-         op.getTrait("::mlir::OpTrait::AttrSizedResultSegments"))
-       return true;
-@@ -670,33 +661,24 @@
-   // type as all results' types.
-   void genUseOperandAsResultTypeSeparateParamBuilder();
- 
--  // The kind of collective builder to generate
--  enum class CollectiveBuilderKind {
--    PropStruct, // Inherent attributes/properties are passed by `const
--                // Properties&`
--    AttrDict,   // Inherent attributes/properties are passed by attribute
--                // dictionary
--  };
--
-   // Generates the build() method that takes all operands/attributes
-   // collectively as one parameter. The generated build() method uses first
-   // operand's type as all results' types.
--  void
--  genUseOperandAsResultTypeCollectiveParamBuilder(CollectiveBuilderKind kind);
-+  void genUseOperandAsResultTypeCollectiveParamBuilder();
- 
-   // Generates the build() method that takes aggregate operands/attributes
-   // parameters. This build() method uses inferred types as result types.
-   // Requires: The type needs to be inferable via InferTypeOpInterface.
--  void genInferredTypeCollectiveParamBuilder(CollectiveBuilderKind kind);
-+  void genInferredTypeCollectiveParamBuilder();
- 
--  // Generates the build() method that takesaggregate operands/attributes as
--  // parameters. The generated build() method uses first attribute's
-+  // Generates the build() method that takes each operand/attribute as a
-+  // stand-alone parameter. The generated build() method uses first attribute's
-   // type as all result's types.
--  void genUseAttrAsResultTypeCollectiveParamBuilder(CollectiveBuilderKind kind);
-+  void genUseAttrAsResultTypeBuilder();
- 
-   // Generates the build() method that takes all result types collectively as
-   // one parameter. Similarly for operands and attributes.
--  void genCollectiveParamBuilder(CollectiveBuilderKind kind);
-+  void genCollectiveParamBuilder();
- 
-   // The kind of parameter to generate for result types in builders.
-   enum class TypeParamKind {
-@@ -1381,6 +1363,8 @@
-     attrOrProperties.push_back(&emitHelper.getOperandSegmentsSize().value());
-   if (emitHelper.getResultSegmentsSize())
-     attrOrProperties.push_back(&emitHelper.getResultSegmentsSize().value());
-+  if (attrOrProperties.empty())
-+    return;
-   auto &setPropMethod =
-       opClass
-           .addStaticMethod(
-@@ -1744,9 +1728,6 @@
- 
- void OpEmitter::genPropertiesSupportForBytecode(
-     ArrayRef<ConstArgument> attrOrProperties) {
--  if (attrOrProperties.empty())
--    return;
+ template <typename _Tp>
+-inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
++inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
+ __to_chars_itoa(char* __first, char* __last, _Tp __value, false_type) {
+   using __tx  = __itoa::__traits<_Tp>;
+   auto __diff = __last - __first;
+@@ -69,7 +73,7 @@
+ 
+ #  if _LIBCPP_HAS_INT128
+ template <>
+-inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
++inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
+ __to_chars_itoa(char* __first, char* __last, __uint128_t __value, false_type) {
+   // When the value fits in 64-bits use the 64-bit code path. This reduces
+   // the number of expensive calculations on 128-bit values.
+@@ -88,20 +92,20 @@
+ }
+ #  endif
+ 
+-template <class _Tp, __enable_if_t<!is_signed<_Tp>::value, int> = 0>
+-inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
+-__to_chars_integral(char* __first, char* __last, _Tp __value, int __base);
 -
-   if (op.useCustomPropertiesEncoding()) {
-     opClass.declareStaticMethod(
-         "::llvm::LogicalResult", "readProperties",
-@@ -2663,8 +2644,7 @@
+-template <class _Tp, __enable_if_t<is_signed<_Tp>::value, int> = 0>
+-inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
+-__to_chars_integral(char* __first, char* __last, _Tp __value, int __base) {
++template <class _Tp>
++inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
++__to_chars_integral(char* __first, char* __last, _Tp __value, int __base, false_type);
++
++template <typename _Tp>
++inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
++__to_chars_integral(char* __first, char* __last, _Tp __value, int __base, true_type) {
+   auto __x = std::__to_unsigned_like(__value);
+   if (__value < 0 && __first != __last) {
+     *__first++ = '-';
+     __x        = std::__complement(__x);
    }
+ 
+-  return std::__to_chars_integral(__first, __last, __x, __base);
++  return std::__to_chars_integral(__first, __last, __x, __base, false_type());
  }
  
--void OpEmitter::genUseOperandAsResultTypeCollectiveParamBuilder(
--    CollectiveBuilderKind kind) {
-+void OpEmitter::genUseOperandAsResultTypeCollectiveParamBuilder() {
-   int numResults = op.getNumResults();
- 
-   // Signature
-@@ -2672,15 +2652,10 @@
-   paramList.emplace_back("::mlir::OpBuilder &", "odsBuilder");
-   paramList.emplace_back("::mlir::OperationState &", builderOpState);
-   paramList.emplace_back("::mlir::ValueRange", "operands");
--  if (kind == CollectiveBuilderKind::PropStruct)
--    paramList.emplace_back("const Properties &", "properties");
-   // Provide default value for `attributes` when its the last parameter
-   StringRef attributesDefaultValue = op.getNumVariadicRegions() ? "" : "{}";
--  StringRef attributesName = kind == CollectiveBuilderKind::PropStruct
--                                 ? "discardableAttributes"
--                                 : "attributes";
-   paramList.emplace_back("::llvm::ArrayRef<::mlir::NamedAttribute>",
--                         attributesName, attributesDefaultValue);
-+                         "attributes", attributesDefaultValue);
-   if (op.getNumVariadicRegions())
-     paramList.emplace_back("unsigned", "numRegions");
- 
-@@ -2693,12 +2668,8 @@
-   // Operands
-   body << "  " << builderOpState << ".addOperands(operands);\n";
- 
--  if (kind == CollectiveBuilderKind::PropStruct)
--    body << "  " << builderOpState
--         << ".useProperties(const_cast<Properties&>(properties));\n";
-   // Attributes
--  body << "  " << builderOpState << ".addAttributes(" << attributesName
--       << ");\n";
-+  body << "  " << builderOpState << ".addAttributes(attributes);\n";
- 
-   // Create the correct number of regions
-   if (int numRegions = op.getNumRegions()) {
-@@ -2781,20 +2752,14 @@
+ namespace __itoa {
+@@ -112,7 +116,7 @@
+ template <>
+ struct _LIBCPP_HIDDEN __integral<2> {
+   template <typename _Tp>
+-  _LIBCPP_HIDE_FROM_ABI static _LIBCPP_CONSTEXPR int __width(_Tp __value) _NOEXCEPT {
++  _LIBCPP_HIDE_FROM_ABI static constexpr int __width(_Tp __value) noexcept {
+     // If value == 0 still need one digit. If the value != this has no
+     // effect since the code scans for the most significant bit set. (Note
+     // that __libcpp_clz doesn't work for 0.)
+@@ -120,7 +124,7 @@
    }
- }
  
--void OpEmitter::genInferredTypeCollectiveParamBuilder(
--    CollectiveBuilderKind kind) {
-+void OpEmitter::genInferredTypeCollectiveParamBuilder() {
-   SmallVector<MethodParameter> paramList;
-   paramList.emplace_back("::mlir::OpBuilder &", "odsBuilder");
-   paramList.emplace_back("::mlir::OperationState &", builderOpState);
-   paramList.emplace_back("::mlir::ValueRange", "operands");
--  if (kind == CollectiveBuilderKind::PropStruct)
--    paramList.emplace_back("const Properties &", "properties");
-   StringRef attributesDefaultValue = op.getNumVariadicRegions() ? "" : "{}";
--  StringRef attributesName = kind == CollectiveBuilderKind::PropStruct
--                                 ? "discardableAttributes"
--                                 : "attributes";
-   paramList.emplace_back("::llvm::ArrayRef<::mlir::NamedAttribute>",
--                         attributesName, attributesDefaultValue);
-+                         "attributes", attributesDefaultValue);
-   if (op.getNumVariadicRegions())
-     paramList.emplace_back("unsigned", "numRegions");
- 
-@@ -2819,11 +2784,7 @@
-          << numNonVariadicOperands
-          << "u && \"mismatched number of parameters\");\n";
-   body << "  " << builderOpState << ".addOperands(operands);\n";
--  if (kind == CollectiveBuilderKind::PropStruct)
--    body << "  " << builderOpState
--         << ".useProperties(const_cast<Properties &>(properties));\n";
--  body << "  " << builderOpState << ".addAttributes(" << attributesName
--       << ");\n";
-+  body << "  " << builderOpState << ".addAttributes(attributes);\n";
- 
-   // Create the correct number of regions
-   if (int numRegions = op.getNumRegions()) {
-@@ -2834,8 +2795,7 @@
+   template <typename _Tp>
+-  _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI static __to_chars_result
++  _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI static to_chars_result
+   __to_chars(char* __first, char* __last, _Tp __value) {
+     ptrdiff_t __cap = __last - __first;
+     int __n         = __width(__value);
+@@ -148,7 +152,7 @@
+ template <>
+ struct _LIBCPP_HIDDEN __integral<8> {
+   template <typename _Tp>
+-  _LIBCPP_HIDE_FROM_ABI static _LIBCPP_CONSTEXPR int __width(_Tp __value) _NOEXCEPT {
++  _LIBCPP_HIDE_FROM_ABI static constexpr int __width(_Tp __value) noexcept {
+     // If value == 0 still need one digit. If the value != this has no
+     // effect since the code scans for the most significat bit set. (Note
+     // that __libcpp_clz doesn't work for 0.)
+@@ -156,7 +160,7 @@
    }
  
-   // Result types
--  if (emitHelper.hasNonEmptyPropertiesStruct() &&
--      kind == CollectiveBuilderKind::AttrDict) {
-+  if (emitHelper.hasProperties()) {
-     // Initialize the properties from Attributes before invoking the infer
-     // function.
-     body << formatv(R"(
-@@ -2907,19 +2867,13 @@
-     emit(AttrParamKind::UnwrappedValue);
+   template <typename _Tp>
+-  _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI static __to_chars_result
++  _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI static to_chars_result
+   __to_chars(char* __first, char* __last, _Tp __value) {
+     ptrdiff_t __cap = __last - __first;
+     int __n         = __width(__value);
+@@ -184,7 +188,7 @@
+ template <>
+ struct _LIBCPP_HIDDEN __integral<16> {
+   template <typename _Tp>
+-  _LIBCPP_HIDE_FROM_ABI static _LIBCPP_CONSTEXPR int __width(_Tp __value) _NOEXCEPT {
++  _LIBCPP_HIDE_FROM_ABI static constexpr int __width(_Tp __value) noexcept {
+     // If value == 0 still need one digit. If the value != this has no
+     // effect since the code scans for the most significat bit set. (Note
+     // that __libcpp_clz doesn't work for 0.)
+@@ -192,7 +196,7 @@
+   }
+ 
+   template <typename _Tp>
+-  _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI static __to_chars_result
++  _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI static to_chars_result
+   __to_chars(char* __first, char* __last, _Tp __value) {
+     ptrdiff_t __cap = __last - __first;
+     int __n         = __width(__value);
+@@ -231,13 +235,13 @@
  }
  
--void OpEmitter::genUseAttrAsResultTypeCollectiveParamBuilder(
--    CollectiveBuilderKind kind) {
-+void OpEmitter::genUseAttrAsResultTypeBuilder() {
-   SmallVector<MethodParameter> paramList;
-   paramList.emplace_back("::mlir::OpBuilder &", "odsBuilder");
-   paramList.emplace_back("::mlir::OperationState &", builderOpState);
-   paramList.emplace_back("::mlir::ValueRange", "operands");
--  if (kind == CollectiveBuilderKind::PropStruct)
--    paramList.emplace_back("const Properties &", "properties");
--  StringRef attributesName = kind == CollectiveBuilderKind::PropStruct
--                                 ? "discardableAttributes"
--                                 : "attributes";
-   paramList.emplace_back("::llvm::ArrayRef<::mlir::NamedAttribute>",
--                         attributesName, "{}");
-+                         "attributes", "{}");
-   auto *m = opClass.addStaticMethod("void", "build", std::move(paramList));
-   // If the builder is redundant, skip generating the method
-   if (!m)
-@@ -2931,44 +2885,28 @@
-   std::string resultType;
-   const auto &namedAttr = op.getAttribute(0);
- 
-+  body << "  auto attrName = " << op.getGetterName(namedAttr.name)
-+       << "AttrName(" << builderOpState
-+       << ".name);\n"
-+          "  for (auto attr : attributes) {\n"
-+          "    if (attr.getName() != attrName) continue;\n";
-   if (namedAttr.attr.isTypeAttr()) {
--    resultType = "::llvm::cast<::mlir::TypeAttr>(typeAttr).getValue()";
--  } else {
--    resultType = "::llvm::cast<::mlir::TypedAttr>(typeAttr).getType()";
+ template <unsigned _Base, typename _Tp, __enable_if_t<(sizeof(_Tp) >= sizeof(unsigned)), int> = 0>
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
+ __to_chars_integral(char* __first, char* __last, _Tp __value) {
+   return __itoa::__integral<_Base>::__to_chars(__first, __last, __value);
+ }
+ 
+ template <unsigned _Base, typename _Tp, __enable_if_t<(sizeof(_Tp) < sizeof(unsigned)), int> = 0>
+-_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
++_LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
+ __to_chars_integral(char* __first, char* __last, _Tp __value) {
+   return std::__to_chars_integral<_Base>(__first, __last, static_cast<unsigned>(__value));
+ }
+@@ -268,9 +272,9 @@
+   __libcpp_unreachable();
+ }
+ 
+-template <class _Tp, __enable_if_t<!is_signed<_Tp>::value, int> >
+-inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI __to_chars_result
+-__to_chars_integral(char* __first, char* __last, _Tp __value, int __base) {
++template <typename _Tp>
++inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
++__to_chars_integral(char* __first, char* __last, _Tp __value, int __base, false_type) {
+   if (__base == 10) [[likely]]
+     return std::__to_chars_itoa(__first, __last, __value, false_type());
+ 
+@@ -298,28 +302,6 @@
+   return {__last, errc(0)};
+ }
+ 
+-_LIBCPP_HIDE_FROM_ABI inline _LIBCPP_CONSTEXPR_SINCE_CXX14 char __hex_to_upper(char __c) {
+-  switch (__c) {
+-  case 'a':
+-    return 'A';
+-  case 'b':
+-    return 'B';
+-  case 'c':
+-    return 'C';
+-  case 'd':
+-    return 'D';
+-  case 'e':
+-    return 'E';
+-  case 'f':
+-    return 'F';
 -  }
+-  return __c;
+-}
 -
--  if (kind == CollectiveBuilderKind::PropStruct) {
--    body << "  ::mlir::Attribute typeAttr = properties."
--         << op.getGetterName(namedAttr.name) << "();\n";
-+    resultType = "::llvm::cast<::mlir::TypeAttr>(attr.getValue()).getValue()";
-   } else {
--    body << "  ::mlir::Attribute typeAttr;\n"
--         << "  auto attrName = " << op.getGetterName(namedAttr.name)
--         << "AttrName(" << builderOpState
--         << ".name);\n"
--            "  for (auto attr : attributes) {\n"
--            "    if (attr.getName() == attrName) {\n"
--            "      typeAttr = attr.getValue();\n"
--            "      break;\n"
--            "    }\n"
--            "  }\n";
-+    resultType = "::llvm::cast<::mlir::TypedAttr>(attr.getValue()).getType()";
-   }
+-#if _LIBCPP_STD_VER >= 17
+-
+-to_chars_result to_chars(char*, char*, bool, int = 10) = delete;
+-
+ template <typename _Tp, __enable_if_t<is_integral<_Tp>::value, int> = 0>
+ inline _LIBCPP_CONSTEXPR_SINCE_CXX23 _LIBCPP_HIDE_FROM_ABI to_chars_result
+ to_chars(char* __first, char* __last, _Tp __value) {
+@@ -334,7 +316,7 @@
+   _LIBCPP_ASSERT_UNCATEGORIZED(2 <= __base && __base <= 36, "base not in [2, 36]");
+ 
+   using _Type = __make_32_64_or_128_bit_t<_Tp>;
+-  return std::__to_chars_integral(__first, __last, static_cast<_Type>(__value), __base);
++  return std::__to_chars_integral(__first, __last, static_cast<_Type>(__value), __base, is_signed<_Tp>());
+ }
  
-   // Operands
-   body << "  " << builderOpState << ".addOperands(operands);\n";
+ #endif // _LIBCPP_STD_VER >= 17
+diff -ruN --strip-trailing-cr a/libcxx/include/__charconv/to_chars_result.h b/libcxx/include/__charconv/to_chars_result.h
+--- a/libcxx/include/__charconv/to_chars_result.h
++++ b/libcxx/include/__charconv/to_chars_result.h
+@@ -34,15 +34,6 @@
  
--  // Properties
--  if (kind == CollectiveBuilderKind::PropStruct)
--    body << "  " << builderOpState
--         << ".useProperties(const_cast<Properties&>(properties));\n";
+ #endif // _LIBCPP_STD_VER >= 17
+ 
+-struct __to_chars_result {
+-  char* __ptr;
+-  errc __ec;
+-
+-#if _LIBCPP_STD_VER >= 17
+-  _LIBCPP_HIDE_FROM_ABI constexpr operator to_chars_result() { return {__ptr, __ec}; }
+-#endif
+-};
 -
-   // Attributes
--  body << "  " << builderOpState << ".addAttributes(" << attributesName
--       << ");\n";
-+  body << "  " << builderOpState << ".addAttributes(attributes);\n";
- 
-   // Result types
-   SmallVector<std::string, 2> resultTypes(op.getNumResults(), resultType);
-   body << "    " << builderOpState << ".addTypes({"
-        << llvm::join(resultTypes, ", ") << "});\n";
-+  body << "  }\n";
+ _LIBCPP_END_NAMESPACE_STD
+ 
+ #endif // _LIBCPP___CHARCONV_TO_CHARS_RESULT_H
+diff -ruN --strip-trailing-cr a/libcxx/include/__charconv/traits.h b/libcxx/include/__charconv/traits.h
+--- a/libcxx/include/__charconv/traits.h
++++ b/libcxx/include/__charconv/traits.h
+@@ -30,13 +30,15 @@
+ 
+ _LIBCPP_BEGIN_NAMESPACE_STD
+ 
++#if _LIBCPP_STD_VER >= 17
++
+ namespace __itoa {
+ 
+ template <typename _Tp, typename = void>
+ struct _LIBCPP_HIDDEN __traits_base;
+ 
+ template <typename _Tp>
+-struct _LIBCPP_HIDDEN __traits_base<_Tp, __enable_if_t<sizeof(_Tp) <= sizeof(uint32_t)> > {
++struct _LIBCPP_HIDDEN __traits_base<_Tp, __enable_if_t<sizeof(_Tp) <= sizeof(uint32_t)>> {
+   using type = uint32_t;
+ 
+   /// The width estimation using a log10 algorithm.
+@@ -62,7 +64,7 @@
+ };
+ 
+ template <typename _Tp>
+-struct _LIBCPP_HIDDEN __traits_base<_Tp, __enable_if_t<sizeof(_Tp) == sizeof(uint64_t)> > {
++struct _LIBCPP_HIDDEN __traits_base<_Tp, __enable_if_t<sizeof(_Tp) == sizeof(uint64_t)>> {
+   using type = uint64_t;
+ 
+   /// The width estimation using a log10 algorithm.
+@@ -151,7 +153,7 @@
+ 
+ template <typename _Tp>
+ struct _LIBCPP_HIDDEN __traits : __traits_base<_Tp> {
+-  static _LIBCPP_CONSTEXPR const int digits = numeric_limits<_Tp>::digits10 + 1;
++  static constexpr int digits = numeric_limits<_Tp>::digits10 + 1;
+   using __traits_base<_Tp>::__pow;
+   using typename __traits_base<_Tp>::type;
+ 
+@@ -190,6 +192,8 @@
+   return _Tp(~__x + 1);
  }
  
- /// Returns a signature of the builder. Updates the context `fctx` to enable
-@@ -3035,32 +2973,22 @@
-   // 1. one having a stand-alone parameter for each operand / attribute, and
-   genSeparateArgParamBuilder();
-   // 2. one having an aggregated parameter for all result types / operands /
--  //    [properties / discardable] attributes, and
--  genCollectiveParamBuilder(CollectiveBuilderKind::AttrDict);
--  if (emitHelper.hasProperties())
--    genCollectiveParamBuilder(CollectiveBuilderKind::PropStruct);
-+  //    attributes, and
-+  genCollectiveParamBuilder();
-   // 3. one having a stand-alone parameter for each operand and attribute,
-   //    use the first operand or attribute's type as all result types
-   //    to facilitate different call patterns.
-   if (op.getNumVariableLengthResults() == 0) {
-     if (op.getTrait("::mlir::OpTrait::SameOperandsAndResultType")) {
-       genUseOperandAsResultTypeSeparateParamBuilder();
--      genUseOperandAsResultTypeCollectiveParamBuilder(
--          CollectiveBuilderKind::AttrDict);
--      if (emitHelper.hasProperties())
--        genUseOperandAsResultTypeCollectiveParamBuilder(
--            CollectiveBuilderKind::PropStruct);
--    }
--    if (op.getTrait("::mlir::OpTrait::FirstAttrDerivedResultType")) {
--      genUseAttrAsResultTypeCollectiveParamBuilder(
--          CollectiveBuilderKind::AttrDict);
--      genUseAttrAsResultTypeCollectiveParamBuilder(
--          CollectiveBuilderKind::PropStruct);
-+      genUseOperandAsResultTypeCollectiveParamBuilder();
-     }
-+    if (op.getTrait("::mlir::OpTrait::FirstAttrDerivedResultType"))
-+      genUseAttrAsResultTypeBuilder();
-   }
++#endif // _LIBCPP_STD_VER >= 17
++
+ _LIBCPP_END_NAMESPACE_STD
+ 
+ _LIBCPP_POP_MACROS
+diff -ruN --strip-trailing-cr a/libcxx/include/__format/formatter_floating_point.h b/libcxx/include/__format/formatter_floating_point.h
+--- a/libcxx/include/__format/formatter_floating_point.h
++++ b/libcxx/include/__format/formatter_floating_point.h
+@@ -19,7 +19,6 @@
+ #include <__assert>
+ #include <__charconv/chars_format.h>
+ #include <__charconv/to_chars_floating_point.h>
+-#include <__charconv/to_chars_integral.h>
+ #include <__charconv/to_chars_result.h>
+ #include <__concepts/arithmetic.h>
+ #include <__concepts/same_as.h>
+diff -ruN --strip-trailing-cr a/libcxx/include/__format/formatter_integral.h b/libcxx/include/__format/formatter_integral.h
+--- a/libcxx/include/__format/formatter_integral.h
++++ b/libcxx/include/__format/formatter_integral.h
+@@ -338,7 +338,7 @@
+   if (__specs.__std_.__type_ != __format_spec::__type::__hexadecimal_upper_case) [[likely]]
+     return __formatter::__write(__first, __last, __ctx.out(), __specs);
+ 
+-  return __formatter::__write_transformed(__first, __last, __ctx.out(), __specs, std::__hex_to_upper);
++  return __formatter::__write_transformed(__first, __last, __ctx.out(), __specs, __formatter::__hex_to_upper);
  }
  
--void OpEmitter::genCollectiveParamBuilder(CollectiveBuilderKind kind) {
-+void OpEmitter::genCollectiveParamBuilder() {
-   int numResults = op.getNumResults();
-   int numVariadicResults = op.getNumVariableLengthResults();
-   int numNonVariadicResults = numResults - numVariadicResults;
-@@ -3074,15 +3002,10 @@
-   paramList.emplace_back("::mlir::OperationState &", builderOpState);
-   paramList.emplace_back("::mlir::TypeRange", "resultTypes");
-   paramList.emplace_back("::mlir::ValueRange", "operands");
--  if (kind == CollectiveBuilderKind::PropStruct)
--    paramList.emplace_back("const Properties &", "properties");
-   // Provide default value for `attributes` when its the last parameter
-   StringRef attributesDefaultValue = op.getNumVariadicRegions() ? "" : "{}";
--  StringRef attributesName = kind == CollectiveBuilderKind::PropStruct
--                                 ? "discardableAttributes"
--                                 : "attributes";
-   paramList.emplace_back("::llvm::ArrayRef<::mlir::NamedAttribute>",
--                         attributesName, attributesDefaultValue);
-+                         "attributes", attributesDefaultValue);
-   if (op.getNumVariadicRegions())
-     paramList.emplace_back("unsigned", "numRegions");
- 
-@@ -3100,14 +3023,8 @@
-          << "u && \"mismatched number of parameters\");\n";
-   body << "  " << builderOpState << ".addOperands(operands);\n";
- 
--  // Properties
--  if (kind == CollectiveBuilderKind::PropStruct)
--    body << "  " << builderOpState
--         << ".useProperties(const_cast<Properties&>(properties));\n";
+ template <unsigned_integral _Tp, class _CharT, class _FormatContext>
+diff -ruN --strip-trailing-cr a/libcxx/include/__format/formatter_output.h b/libcxx/include/__format/formatter_output.h
+--- a/libcxx/include/__format/formatter_output.h
++++ b/libcxx/include/__format/formatter_output.h
+@@ -45,6 +45,24 @@
+ 
+ namespace __formatter {
+ 
++_LIBCPP_HIDE_FROM_ABI constexpr char __hex_to_upper(char __c) {
++  switch (__c) {
++  case 'a':
++    return 'A';
++  case 'b':
++    return 'B';
++  case 'c':
++    return 'C';
++  case 'd':
++    return 'D';
++  case 'e':
++    return 'E';
++  case 'f':
++    return 'F';
++  }
++  return __c;
++}
++
+ struct _LIBCPP_EXPORTED_FROM_ABI __padding_size_result {
+   size_t __before_;
+   size_t __after_;
+diff -ruN --strip-trailing-cr a/libcxx/include/locale b/libcxx/include/locale
+--- a/libcxx/include/locale
++++ b/libcxx/include/locale
+@@ -201,8 +201,6 @@
+ #    include <__algorithm/reverse.h>
+ #    include <__algorithm/unwrap_iter.h>
+ #    include <__assert>
+-#    include <__charconv/to_chars_integral.h>
+-#    include <__charconv/traits.h>
+ #    include <__iterator/access.h>
+ #    include <__iterator/back_insert_iterator.h>
+ #    include <__iterator/istreambuf_iterator.h>
+@@ -212,7 +210,6 @@
+ #    include <__memory/addressof.h>
+ #    include <__memory/unique_ptr.h>
+ #    include <__new/exceptions.h>
+-#    include <__system_error/errc.h>
+ #    include <__type_traits/make_unsigned.h>
+ #    include <cerrno>
+ #    include <cstdio>
+@@ -1224,7 +1221,7 @@
+ 
+   template <class _Integral>
+   _LIBCPP_HIDE_FROM_ABI inline _OutputIterator
+-  __do_put_integral(iter_type __s, ios_base& __iob, char_type __fl, _Integral __v) const;
++  __do_put_integral(iter_type __s, ios_base& __iob, char_type __fl, _Integral __v, char const* __len) const;
+ 
+   template <class _Float>
+   _LIBCPP_HIDE_FROM_ABI inline _OutputIterator
+@@ -1250,68 +1247,30 @@
+ template <class _CharT, class _OutputIterator>
+ template <class _Integral>
+ _LIBCPP_HIDE_FROM_ABI inline _OutputIterator num_put<_CharT, _OutputIterator>::__do_put_integral(
+-    iter_type __s, ios_base& __iob, char_type __fl, _Integral __v) const {
++    iter_type __s, ios_base& __iob, char_type __fl, _Integral __v, char const* __len) const {
+   // Stage 1 - Get number in narrow char
+-
++  char __fmt[8] = {'%', 0};
++  this->__format_int(__fmt + 1, __len, is_signed<_Integral>::value, __iob.flags());
+   // Worst case is octal, with showbase enabled. Note that octal is always
+   // printed as an unsigned value.
+   using _Unsigned = typename make_unsigned<_Integral>::type;
+-  _LIBCPP_CONSTEXPR const unsigned __buffer_size =
++  _LIBCPP_CONSTEXPR const unsigned __nbuf =
+       (numeric_limits<_Unsigned>::digits / 3)          // 1 char per 3 bits
+       + ((numeric_limits<_Unsigned>::digits % 3) != 0) // round up
+       + 2;                                             // base prefix + terminating null character
+-
+-  char __char_buffer[__buffer_size];
+-  char* __buffer_ptr = __char_buffer;
+-
+-  auto __flags = __iob.flags();
+-
+-  auto __basefield = (__flags & ios_base::basefield);
+-
+-  // Extract base
+-  int __base = 10;
+-  if (__basefield == ios_base::oct)
+-    __base = 8;
+-  else if (__basefield == ios_base::hex)
+-    __base = 16;
+-
+-  // Print '-' and make the argument unsigned
+-  auto __uval = std::__to_unsigned_like(__v);
+-  if (__basefield != ios_base::oct && __basefield != ios_base::hex && __v < 0) {
+-    *__buffer_ptr++ = '-';
+-    __uval          = std::__complement(__uval);
+-  }
+-
+-  // Maybe add '+' prefix
+-  if (std::is_signed<_Integral>::value && (__flags & ios_base::showpos) && __basefield != ios_base::oct &&
+-      __basefield != ios_base::hex && __v > 0)
+-    *__buffer_ptr++ = '+';
+-
+-  // Add base prefix
+-  if (__flags & ios_base::showbase) {
+-    if (__basefield == ios_base::oct) {
+-      *__buffer_ptr++ = '0';
+-    } else if (__basefield == ios_base::hex) {
+-      *__buffer_ptr++ = '0';
+-      *__buffer_ptr++ = (__flags & ios_base::uppercase ? 'X' : 'x');
+-    }
+-  }
 -
-   // Attributes
--  body << "  " << builderOpState << ".addAttributes(" << attributesName
--       << ");\n";
-+  body << "  " << builderOpState << ".addAttributes(attributes);\n";
- 
-   // Create the correct number of regions
-   if (int numRegions = op.getNumRegions()) {
-@@ -3124,8 +3041,7 @@
-          << "u && \"mismatched number of return types\");\n";
-   body << "  " << builderOpState << ".addTypes(resultTypes);\n";
- 
--  if (emitHelper.hasNonEmptyPropertiesStruct() &&
--      kind == CollectiveBuilderKind::AttrDict) {
-+  if (emitHelper.hasProperties()) {
-     // Initialize the properties from Attributes before invoking the infer
-     // function.
-     body << formatv(R"(
-@@ -3144,7 +3060,7 @@
-   // Generate builder that infers type too.
-   // TODO: Expand to handle successors.
-   if (canInferType(op) && op.getNumSuccessors() == 0)
--    genInferredTypeCollectiveParamBuilder(kind);
-+    genInferredTypeCollectiveParamBuilder();
+-  auto __res = std::__to_chars_integral(__buffer_ptr, __char_buffer + __buffer_size, __uval, __base);
+-  _LIBCPP_ASSERT_INTERNAL(__res.__ec == std::errc(), "to_chars: invalid maximum buffer size computed?");
+-
+-  // Make letters uppercase
+-  if (__flags & ios_base::hex && __flags & ios_base::uppercase) {
+-    for (; __buffer_ptr != __res.__ptr; ++__buffer_ptr)
+-      *__buffer_ptr = std::__hex_to_upper(*__buffer_ptr);
+-  }
+-
+-  char* __np = this->__identify_padding(__char_buffer, __res.__ptr, __iob);
++  char __nar[__nbuf];
++  _LIBCPP_DIAGNOSTIC_PUSH
++  _LIBCPP_CLANG_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
++  _LIBCPP_GCC_DIAGNOSTIC_IGNORED("-Wformat-nonliteral")
++  int __nc = __locale::__snprintf(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);
++  _LIBCPP_DIAGNOSTIC_POP
++  char* __ne = __nar + __nc;
++  char* __np = this->__identify_padding(__nar, __ne, __iob);
+   // Stage 2 - Widen __nar while adding thousands separators
+-  char_type __o[2 * (__buffer_size - 1) - 1];
++  char_type __o[2 * (__nbuf - 1) - 1];
+   char_type* __op; // pad here
+   char_type* __oe; // end of output
+-  this->__widen_and_group_int(__char_buffer, __np, __res.__ptr, __o, __op, __oe, __iob.getloc());
++  this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());
+   // [__o, __oe) contains thousands_sep'd wide number
+   // Stage 3 & 4
+   return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
+@@ -1320,25 +1279,25 @@
+ template <class _CharT, class _OutputIterator>
+ _OutputIterator
+ num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long __v) const {
+-  return this->__do_put_integral(__s, __iob, __fl, __v);
++  return this->__do_put_integral(__s, __iob, __fl, __v, "l");
  }
  
- void OpEmitter::buildParamList(SmallVectorImpl<MethodParameter> &paramList,
-@@ -4145,7 +4061,7 @@
-   // native/interface traits and after all the traits with `StructuralOpTrait`.
-   opClass.addTrait("::mlir::OpTrait::OpInvariants");
- 
--  if (emitHelper.hasNonEmptyPropertiesStruct())
-+  if (emitHelper.hasProperties())
-     opClass.addTrait("::mlir::BytecodeOpInterface::Trait");
- 
-   // Add the native and interface traits.
-@@ -4285,6 +4201,7 @@
-       attrOrProperties.push_back(&emitHelper.getOperandSegmentsSize().value());
-     if (emitHelper.getResultSegmentsSize())
-       attrOrProperties.push_back(&emitHelper.getResultSegmentsSize().value());
-+    assert(!attrOrProperties.empty());
-     std::string declarations = "  struct Properties {\n";
-     llvm::raw_string_ostream os(declarations);
-     std::string comparator =
-@@ -4357,7 +4274,7 @@
-       // Emit accessors using the interface type.
-       if (attr) {
-         const char *accessorFmt = R"decl(
--    auto get{0}() const {
-+    auto get{0}() {
-       auto &propStorage = this->{1};
-       return ::llvm::{2}<{3}>(propStorage);
-     }
-@@ -4379,12 +4296,7 @@
-     os << comparator;
-     os << "  };\n";
- 
--    if (attrOrProperties.empty())
--      genericAdaptorBase.declare<UsingDeclaration>("Properties",
--                                                   "::mlir::EmptyProperties");
--    else
--      genericAdaptorBase.declare<ExtraClassDeclaration>(
--          std::move(declarations));
-+    genericAdaptorBase.declare<ExtraClassDeclaration>(std::move(declarations));
-   }
-   genericAdaptorBase.declare<VisibilityDeclaration>(Visibility::Protected);
-   genericAdaptorBase.declare<Field>("::mlir::DictionaryAttr", "odsAttrs");
-diff -ruN --strip-trailing-cr a/mlir/unittests/TableGen/OpBuildGen.cpp b/mlir/unittests/TableGen/OpBuildGen.cpp
---- a/mlir/unittests/TableGen/OpBuildGen.cpp
-+++ b/mlir/unittests/TableGen/OpBuildGen.cpp
-@@ -291,20 +291,4 @@
-   verifyOp(std::move(op), {f32Ty}, {*cstI32}, {*cstI32}, attrs);
+ template <class _CharT, class _OutputIterator>
+ _OutputIterator
+ num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, long long __v) const {
+-  return this->__do_put_integral(__s, __iob, __fl, __v);
++  return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
+ }
+ 
+ template <class _CharT, class _OutputIterator>
+ _OutputIterator
+ num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long __v) const {
+-  return this->__do_put_integral(__s, __iob, __fl, __v);
++  return this->__do_put_integral(__s, __iob, __fl, __v, "l");
  }
  
--TEST_F(OpBuildGenTest, BuildMethodsInherentDiscardableAttrs) {
--  test::TableGenBuildOp7::Properties props;
--  props.attr0 = cast<BoolAttr>(attrs[0].getValue());
--  ArrayRef<NamedAttribute> discardableAttrs = attrs.drop_front();
--  auto op7 = builder.create<test::TableGenBuildOp7>(
--      loc, TypeRange{}, ValueRange{}, props, discardableAttrs);
--  verifyOp(op7, {}, {}, attrs);
+ template <class _CharT, class _OutputIterator>
+ _OutputIterator
+ num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, unsigned long long __v) const {
+-  return this->__do_put_integral(__s, __iob, __fl, __v);
++  return this->__do_put_integral(__s, __iob, __fl, __v, "ll");
+ }
+ 
+ template <class _CharT, class _OutputIterator>
+@@ -1406,11 +1365,26 @@
+ template <class _CharT, class _OutputIterator>
+ _OutputIterator
+ num_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob, char_type __fl, const void* __v) const {
+-  auto __flags = __iob.flags();
+-  __iob.flags((__flags & ~ios_base::basefield & ~ios_base::uppercase) | ios_base::hex | ios_base::showbase);
+-  auto __res = __do_put_integral(__s, __iob, __fl, reinterpret_cast<uintptr_t>(__v));
+-  __iob.flags(__flags);
+-  return __res;
++  // Stage 1 - Get pointer in narrow char
++  const unsigned __nbuf = 20;
++  char __nar[__nbuf];
++  int __nc   = __locale::__snprintf(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, "%p", __v);
++  char* __ne = __nar + __nc;
++  char* __np = this->__identify_padding(__nar, __ne, __iob);
++  // Stage 2 - Widen __nar
++  char_type __o[2 * (__nbuf - 1) - 1];
++  char_type* __op; // pad here
++  char_type* __oe; // end of output
++  const ctype<char_type>& __ct = std::use_facet<ctype<char_type> >(__iob.getloc());
++  __ct.widen(__nar, __ne, __o);
++  __oe = __o + (__ne - __nar);
++  if (__np == __ne)
++    __op = __oe;
++  else
++    __op = __o + (__np - __nar);
++  // [__o, __oe) contains wide number
++  // Stage 3 & 4
++  return std::__pad_and_output(__s, __o, __op, __oe, __iob, __fl);
+ }
+ 
+ extern template class _LIBCPP_EXTERN_TEMPLATE_TYPE_VIS num_put<char>;
+diff -ruN --strip-trailing-cr a/libcxx/include/module.modulemap b/libcxx/include/module.modulemap
+--- a/libcxx/include/module.modulemap
++++ b/libcxx/include/module.modulemap
+@@ -925,10 +925,7 @@
+     module to_chars                   { header "__charconv/to_chars.h" }
+     module to_chars_base_10           { header "__charconv/to_chars_base_10.h" }
+     module to_chars_floating_point    { header "__charconv/to_chars_floating_point.h" }
+-    module to_chars_integral          {
+-      header "__charconv/to_chars_integral.h"
+-      export std.charconv.to_chars_result
+-    }
++    module to_chars_integral          { header "__charconv/to_chars_integral.h" }
+     module to_chars_result            { header "__charconv/to_chars_result.h" }
+     module traits                     { header "__charconv/traits.h" }
+ 
+diff -ruN --strip-trailing-cr a/libcxx/test/benchmarks/locale/num_put.bench.cpp b/libcxx/test/benchmarks/locale/num_put.bench.cpp
+--- a/libcxx/test/benchmarks/locale/num_put.bench.cpp
++++ b/libcxx/test/benchmarks/locale/num_put.bench.cpp
+@@ -1,39 +0,0 @@
+-//===----------------------------------------------------------------------===//
+-//
+-// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+-// See https://llvm.org/LICENSE.txt for license information.
+-// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+-//
+-//===----------------------------------------------------------------------===//
 -
--  // Check that the old-style builder where all the attributes go in the same
--  // place works.
--  auto op7b = builder.create<test::TableGenBuildOp7>(loc, TypeRange{},
--                                                     ValueRange{}, attrs);
--  verifyOp(op7b, {}, {}, attrs);
--  ASSERT_EQ(op7b.getProperties().getAttr0(), attrs[0].getValue());
+-// UNSUPPORTED: c++03
+-
+-#include <ios>
+-#include <locale>
+-
+-#include <benchmark/benchmark.h>
+-
+-struct num_put : std::num_put<char, std::string::iterator> {};
+-
+-template <class T>
+-void BM_num_put(benchmark::State& state) {
+-  auto val = T(123);
+-  std::ios ios(nullptr);
+-  num_put np;
+-
+-  for (auto _ : state) {
+-    benchmark::DoNotOptimize(val);
+-    std::string str;
+-    benchmark::DoNotOptimize(np.put(str.begin(), ios, ' ', val));
+-  }
 -}
+-BENCHMARK(BM_num_put<bool>);
+-BENCHMARK(BM_num_put<long>);
+-BENCHMARK(BM_num_put<long long>);
+-BENCHMARK(BM_num_put<unsigned long>);
+-BENCHMARK(BM_num_put<unsigned long long>);
+-BENCHMARK(BM_num_put<double>);
+-BENCHMARK(BM_num_put<long double>);
+-BENCHMARK(BM_num_put<const void*>);
+-
+-BENCHMARK_MAIN();
+diff -ruN --strip-trailing-cr a/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_pointer.pass.cpp b/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_pointer.pass.cpp
+--- a/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_pointer.pass.cpp
++++ b/libcxx/test/std/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members/put_pointer.pass.cpp
+@@ -12,32 +12,40 @@
+ 
+ // iter_type put(iter_type s, ios_base& iob, char_type fill, void* v) const;
+ 
+-// XFAIL: FROZEN-CXX03-HEADERS-FIXME
+-
+-#include <cassert>
+-#include <ios>
+ #include <locale>
+-
++#include <ios>
++#include <cassert>
++#include <streambuf>
++#include "test_macros.h"
+ #include "test_iterators.h"
+ 
+ typedef std::num_put<char, cpp17_output_iterator<char*> > F;
+ 
+-class my_facet : public F {
++class my_facet
++    : public F
++{
+ public:
+-  explicit my_facet(std::size_t refs = 0) : F(refs) {}
++    explicit my_facet(std::size_t refs = 0)
++        : F(refs) {}
+ };
+ 
+-int main(int, char**) {
+-  const my_facet f(1);
+-  {
+-    std::ios ios(nullptr);
+-    void* v = nullptr;
+-    char str[50];
+-    cpp17_output_iterator<char*> iter = f.put(cpp17_output_iterator<char*>(str), ios, '*', v);
+-    std::string ex(str, base(iter));
+-    assert(!ex.empty());
+-    LIBCPP_ASSERT(ex == "0x0");
+-  }
++int main(int, char**)
++{
++    const my_facet f(1);
++    {
++        std::ios ios(0);
++        void* v = 0;
++        char str[50];
++        cpp17_output_iterator<char*> iter = f.put(cpp17_output_iterator<char*>(str), ios, '*', v);
++        std::string ex(str, base(iter));
++        char expected_str[32] = {};
++        // num_put::put uses %p for pointer types, but the exact format of %p is
++        // implementation defined behavior for the C library. Compare output to
++        // snprintf for portability.
++        int rc = snprintf(expected_str, sizeof(expected_str), "%p", v);
++        assert(rc > 0);
++        assert(ex == expected_str);
++    }
+ 
+   return 0;
+ }
+diff -ruN --strip-trailing-cr a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+--- a/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
++++ b/llvm/lib/Transforms/Vectorize/SLPVectorizer.cpp
+@@ -14103,9 +14103,7 @@
+             TEUseEI.UserTE->getOpcode() == Instruction::PHI &&
+             UseEI.UserTE->State == TreeEntry::Vectorize &&
+             UseEI.UserTE->getOpcode() == Instruction::PHI &&
+-            TEUseEI.UserTE != UseEI.UserTE &&
+-            TEUseEI.UserTE->getMainOp()->getParent() ==
+-                UseEI.UserTE->getMainOp()->getParent())
++            TEUseEI.UserTE != UseEI.UserTE)
+           continue;
+         // If 2 gathers are operands of the same entry (regardless of whether
+         // user is PHI or else), compare operands indices, use the earlier one
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/delayed-gather-emission.ll b/llvm/test/Transforms/SLPVectorizer/X86/delayed-gather-emission.ll
+--- a/llvm/test/Transforms/SLPVectorizer/X86/delayed-gather-emission.ll
++++ b/llvm/test/Transforms/SLPVectorizer/X86/delayed-gather-emission.ll
+@@ -29,9 +29,9 @@
+ ; CHECK-NEXT:    tail call void @foo(float [[MUL]])
+ ; CHECK-NEXT:    [[I2:%.*]] = load float, ptr poison, align 4
+ ; CHECK-NEXT:    [[TOBOOL:%.*]] = fcmp une float [[I2]], 0.000000e+00
++; CHECK-NEXT:    [[TMP10]] = insertelement <2 x float> [[TMP2]], float [[I2]], i32 0
+ ; CHECK-NEXT:    [[TMP8:%.*]] = shufflevector <2 x float> [[TMP5]], <2 x float> poison, <2 x i32> <i32 poison, i32 0>
+ ; CHECK-NEXT:    [[TMP9]] = insertelement <2 x float> [[TMP8]], float [[I2]], i32 0
+-; CHECK-NEXT:    [[TMP10]] = shufflevector <2 x float> [[TMP9]], <2 x float> [[TMP2]], <2 x i32> <i32 0, i32 3>
+ ; CHECK-NEXT:    br i1 [[TOBOOL]], label [[BB1]], label [[BB2]]
+ ;
+ entry:
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/matching-gather-nodes-phi-users.ll b/llvm/test/Transforms/SLPVectorizer/X86/matching-gather-nodes-phi-users.ll
+--- a/llvm/test/Transforms/SLPVectorizer/X86/matching-gather-nodes-phi-users.ll
++++ b/llvm/test/Transforms/SLPVectorizer/X86/matching-gather-nodes-phi-users.ll
+@@ -8,7 +8,7 @@
+ ; YAML: Function:        test
+ ; YAML: Args:
+ ; YAML:   - String:          'Stores SLP vectorized with cost '
+-; YAML:   - Cost:            '-6'
++; YAML:   - Cost:            '-3'
+ ; YAML:   - String:          ' and with tree size '
+ ; YAML:   - TreeSize:        '16'
+ ; YAML: ...
+diff -ruN --strip-trailing-cr a/llvm/test/Transforms/SLPVectorizer/X86/phi-nodes-incoming-same-blocks.ll b/llvm/test/Transforms/SLPVectorizer/X86/phi-nodes-incoming-same-blocks.ll
+--- a/llvm/test/Transforms/SLPVectorizer/X86/phi-nodes-incoming-same-blocks.ll
++++ b/llvm/test/Transforms/SLPVectorizer/X86/phi-nodes-incoming-same-blocks.ll
+@@ -0,0 +1,63 @@
++; NOTE: Assertions have been autogenerated by utils/update_test_checks.py UTC_ARGS: --version 5
++; RUN: opt -S --passes=slp-vectorizer -mtriple=x86_64-unknown-linux-gnu -mcpu=cascadelake < %s | FileCheck %s
++
++define void @test(ptr %0, i1 %1, i1 %2) {
++; CHECK-LABEL: define void @test(
++; CHECK-SAME: ptr [[TMP0:%.*]], i1 [[TMP1:%.*]], i1 [[TMP2:%.*]]) #[[ATTR0:[0-9]+]] {
++; CHECK-NEXT:    br label %[[BB4:.*]]
++; CHECK:       [[BB4]]:
++; CHECK-NEXT:    [[TMP5:%.*]] = phi <2 x i32> [ [[TMP12:%.*]], %[[TMP7:.*]] ], [ zeroinitializer, [[TMP3:%.*]] ]
++; CHECK-NEXT:    [[TMP6:%.*]] = shufflevector <2 x i32> [[TMP5]], <2 x i32> poison, <4 x i32> <i32 0, i32 0, i32 0, i32 1>
++; CHECK-NEXT:    br i1 [[TMP1]], label %[[TMP7]], label %[[BB14:.*]]
++; CHECK:       [[TMP7]]:
++; CHECK-NEXT:    [[TMP8:%.*]] = load ptr, ptr [[TMP0]], align 8
++; CHECK-NEXT:    [[TMP9:%.*]] = getelementptr i8, ptr [[TMP8]], i64 16
++; CHECK-NEXT:    [[TMP10:%.*]] = load <2 x i32>, ptr [[TMP9]], align 1
++; CHECK-NEXT:    [[TMP11:%.*]] = or <2 x i32> [[TMP10]], splat (i32 1)
++; CHECK-NEXT:    [[TMP12]] = shufflevector <2 x i32> [[TMP11]], <2 x i32> <i32 1, i32 poison>, <2 x i32> <i32 2, i32 1>
++; CHECK-NEXT:    [[TMP13:%.*]] = call <4 x i32> @llvm.vector.insert.v4i32.v2i32(<4 x i32> <i32 0, i32 0, i32 poison, i32 poison>, <2 x i32> [[TMP11]], i64 2)
++; CHECK-NEXT:    br i1 [[TMP2]], label %[[BB15:.*]], label %[[BB4]]
++; CHECK:       [[BB14]]:
++; CHECK-NEXT:    br label %[[BB15]]
++; CHECK:       [[BB15]]:
++; CHECK-NEXT:    [[TMP16:%.*]] = phi <4 x i32> [ [[TMP6]], %[[BB14]] ], [ [[TMP13]], %[[TMP7]] ]
++; CHECK-NEXT:    [[TMP17:%.*]] = load volatile ptr, ptr null, align 8
++; CHECK-NEXT:    [[TMP18:%.*]] = getelementptr i8, ptr [[TMP17]], i64 176
++; CHECK-NEXT:    store <4 x i32> [[TMP16]], ptr [[TMP18]], align 8
++; CHECK-NEXT:    ret void
++;
++  br label %4
++
++4:
++  %5 = phi i32 [ %14, %7 ], [ 0, %3 ]
++  %6 = phi i32 [ 1, %7 ], [ 0, %3 ]
++  br i1 %1, label %7, label %15
++
++7:
++  %8 = load ptr, ptr %0, align 8
++  %9 = getelementptr i8, ptr %8, i64 16
++  %10 = load i32, ptr %9, align 1
++  %11 = or i32 %10, 1
++  %12 = getelementptr i8, ptr %8, i64 20
++  %13 = load i32, ptr %12, align 1
++  %14 = or i32 %13, 1
++  br i1 %2, label %16, label %4
++
++15:
++  br label %16
++
++16:
++  %17 = phi i32 [ %6, %15 ], [ 0, %7 ]
++  %18 = phi i32 [ %6, %15 ], [ %11, %7 ]
++  %19 = phi i32 [ %5, %15 ], [ %14, %7 ]
++  %20 = load volatile ptr, ptr null, align 8
++  %21 = getelementptr i8, ptr %20, i64 176
++  store i32 %17, ptr %21, align 8
++  %22 = getelementptr i8, ptr %20, i64 180
++  store i32 %17, ptr %22, align 4
++  %23 = getelementptr i8, ptr %20, i64 184
++  store i32 %18, ptr %23, align 8
++  %24 = getelementptr i8, ptr %20, i64 188
++  store i32 %19, ptr %24, align 4
++  ret void
++}
+diff -ruN --strip-trailing-cr a/utils/bazel/llvm-project-overlay/libc/libc_configure_options.bzl b/utils/bazel/llvm-project-overlay/libc/libc_configure_options.bzl
+--- a/utils/bazel/llvm-project-overlay/libc/libc_configure_options.bzl
++++ b/utils/bazel/llvm-project-overlay/libc/libc_configure_options.bzl
+@@ -44,11 +44,6 @@
+     # "LIBC_COPT_STRTOFLOAT_DISABLE_EISEL_LEMIRE",
+     # "LIBC_COPT_STRTOFLOAT_DISABLE_SIMPLE_DECIMAL_CONVERSION",
+ 
+-    # Documentation in libc/src/errno/...
+-    # Since we're only using Bazel for overlay build for now, explicitly
+-    # enforce using the system-provided errno in both tests and release build.
+-    "LIBC_ERRNO_MODE=LIBC_ERRNO_MODE_SYSTEM",
 -
- } // namespace mlir
+     # Documentation in libc/src/__support/libc_assert.h
+     # "LIBC_COPT_USE_C_ASSERT",
+ ]
diff --git a/third_party/llvm/workspace.bzl b/third_party/llvm/workspace.bzl
index 8729f97..dac6899 100644
--- a/third_party/llvm/workspace.bzl
+++ b/third_party/llvm/workspace.bzl
@@ -4,8 +4,8 @@ load("//third_party:repo.bzl", "tf_http_archive")
 
 def repo(name):
     """Imports LLVM."""
-    LLVM_COMMIT = "f01e760c08365426de95f02dc2c2dc670eb47352"
-    LLVM_SHA256 = "abd6f774f8580a9694dc847bd9ce624a4f3e8784543331a6255e2cc6967a6e41"
+    LLVM_COMMIT = "0230d63b4a8b9f420b0aaac373891df1199715a8"
+    LLVM_SHA256 = "27641dbb2ee0fecb6f084a4300b0c27ac692c2d1214fad236dc5e19dd7962693"
 
     tf_http_archive(
         name = name,
